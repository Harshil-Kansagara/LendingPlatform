/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL_NEW = new InjectionToken<string>('API_BASE_URL_NEW');

@Injectable()
export class ApplicationService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL_NEW) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    /**
     * Retrieve list of all applications.
     * @param pageNo (optional) Page number
     * @param pageRecordCount (optional) Page Record Count
     * @param filters (optional) 
     * @param filter (optional) Filter Object
    [{"field1","operator","value"},{"field2","operator","value"}]
     * @param sortField (optional) Field name for sorting.
     * @param sortBy (optional) Sorting option
     * @return Returns list of loans
     */
    getLoanApplicationList(pageNo: number | null | undefined, pageRecordCount: number | null | undefined, filters: FilterAC[] | null | undefined, filter: string | null | undefined, sortField: string | null | undefined, sortBy: string | null | undefined): Observable<PagedLoanApplicationsAC> {
        let url_ = this.baseUrl + "/api/applications?";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageRecordCount !== undefined && pageRecordCount !== null)
            url_ += "PageRecordCount=" + encodeURIComponent("" + pageRecordCount) + "&";
        if (filters !== undefined && filters !== null)
            filters && filters.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanApplicationList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanApplicationList(<any>response_);
                } catch (e) {
                    return <Observable<PagedLoanApplicationsAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedLoanApplicationsAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanApplicationList(response: HttpResponseBase): Observable<PagedLoanApplicationsAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedLoanApplicationsAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedLoanApplicationsAC>(<any>null);
    }

    /**
     * Capture a loan application.
     * @param application Application is the object which can be use to fill the loan application's basic details
     * @return Returns the newly created loan application object
     */
    addLoanApplicationBasicDetails(application: ApplicationBasicDetailAC): Observable<ApplicationBasicDetailAC> {
        let url_ = this.baseUrl + "/api/applications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(application);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLoanApplicationBasicDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLoanApplicationBasicDetails(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(response_);
        }));
    }

    protected processAddLoanApplicationBasicDetails(response: HttpResponseBase): Observable<ApplicationBasicDetailAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationBasicDetailAC.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationBasicDetailAC>(<any>null);
    }

    /**
     * Retrieve the loan application details.
     * @param id Id of the loan application whose details are to be fetched
     * @return Returns the list of recommended loan products
     */
    getLoanApplicationDetailsById(id: string): Observable<ApplicationAC> {
        let url_ = this.baseUrl + "/api/applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanApplicationDetailsById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanApplicationDetailsById(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanApplicationDetailsById(response: HttpResponseBase): Observable<ApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If the relevant data not found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationAC>(<any>null);
    }

    /**
     * Update an existing loan application.
     * @param id Id of the loan application whose details need to be updated
     * @param application Application is the object which can be use to fill the loan application's basic details
     * @return Returns the updated loan application object
     */
    updateLoanApplicationBasicDetails(id: string, application: ApplicationBasicDetailAC): Observable<ApplicationBasicDetailAC> {
        let url_ = this.baseUrl + "/api/applications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(application);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanApplicationBasicDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanApplicationBasicDetails(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanApplicationBasicDetails(response: HttpResponseBase): Observable<ApplicationBasicDetailAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationBasicDetailAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationBasicDetailAC>(<any>null);
    }

    /**
     * Retrieve list of recommended products.
     * @param id Id of the loan application for which the recommended loan products are to be fetched
     * @return Returns the list of recommended loan products
     */
    getRecommendedLoanProducts(id: string): Observable<RecommendedProductAC[]> {
        let url_ = this.baseUrl + "/api/applications/{id}/recommended-products";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommendedLoanProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommendedLoanProducts(<any>response_);
                } catch (e) {
                    return <Observable<RecommendedProductAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecommendedProductAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecommendedLoanProducts(response: HttpResponseBase): Observable<RecommendedProductAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the request doesn\'t authenticate to access the resource", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RecommendedProductAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecommendedProductAC[]>(<any>null);
    }

    /**
     * Retrieve the detail of selected product as per loan application
     * @param id Loan Application Id
     * @return Returns the list of recommended loan products
     */
    getSelectedProduct(id: string): Observable<RecommendedProductAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/product";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSelectedProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSelectedProduct(<any>response_);
                } catch (e) {
                    return <Observable<RecommendedProductAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecommendedProductAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetSelectedProduct(response: HttpResponseBase): Observable<RecommendedProductAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the request doesn\'t authenticate to access the resource", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecommendedProductAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecommendedProductAC>(<any>null);
    }

    /**
     * Capture loan product
     * @param id Loan application id
     * @param productId Product Id
     * @return Return status created when product is link with loan application
     */
    saveProduct(id: string, productId: string): Observable<ApplicationAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/product/{productId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (productId === undefined || productId === null)
            throw new Error("The parameter 'productId' must be defined.");
        url_ = url_.replace("{productId}", encodeURIComponent("" + productId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveProduct(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processSaveProduct(response: HttpResponseBase): Observable<ApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ApplicationAC.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationAC>(<any>null);
    }

    /**
     * Retrieve the bank details of the loan application.
     * @param id Id of the loan application whose details are to be fetched
     * @return Returns the bank details.
     */
    getBankDetailsOfLoanApplication(id: string): Observable<LoanEntityBankDetailsAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/bank-info";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankDetailsOfLoanApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankDetailsOfLoanApplication(<any>response_);
                } catch (e) {
                    return <Observable<LoanEntityBankDetailsAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanEntityBankDetailsAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankDetailsOfLoanApplication(response: HttpResponseBase): Observable<LoanEntityBankDetailsAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanEntityBankDetailsAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If the relevant data not found.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanEntityBankDetailsAC>(<any>null);
    }

    /**
     * Capture the loan application's bank informations.
     * @param loanEntityBankDetailsAC LoanEntityBankDetailsAC is the object which can be use to fill the details of entity's banks for a particular loan application.
     * @return Returns the status of successful add operation
     */
    addBankDetails(loanEntityBankDetailsAC: LoanEntityBankDetailsAC, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/applications/{id}/bank-info";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanEntityBankDetailsAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddBankDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddBankDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddBankDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Update the loan application's bank informations.
     * @param loanEntityBankDetailsAC LoanEntityBankDetailsAC is the object which can be use to fill the details of entity's banks for a particular loan application.
     * @return Returns the status of successful update operation
     */
    updateBankDetails(loanEntityBankDetailsAC: LoanEntityBankDetailsAC, id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/applications/{id}/bank-info";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanEntityBankDetailsAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateBankDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateBankDetails(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateBankDetails(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Link loan application with borrowing entity.
     * @param applicationId Unique identifier of application object
     * @param borrowingEntityId Unique identifier of entity object
     * @return Returns nothing
     */
    linkApplicationWithEntity(applicationId: string, borrowingEntityId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/applications/applications/{applicationId}/entity/{borrowingEntityId}";
        if (applicationId === undefined || applicationId === null)
            throw new Error("The parameter 'applicationId' must be defined.");
        url_ = url_.replace("{applicationId}", encodeURIComponent("" + applicationId));
        if (borrowingEntityId === undefined || borrowingEntityId === null)
            throw new Error("The parameter 'borrowingEntityId' must be defined.");
        url_ = url_.replace("{borrowingEntityId}", encodeURIComponent("" + borrowingEntityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLinkApplicationWithEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLinkApplicationWithEntity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLinkApplicationWithEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve company finances for a loan application
     * @param id Id of Loan for which financial information is needed
     * @param statementCsv Comma separated list of report names. Any of these ["Income Statement","Balance Sheet","Cash Flow","Financial Ratios"]
     * @return Retrieve the finances
     */
    getFinances(id: string, statementCsv: string | null): Observable<CompanyFinanceAC[]> {
        let url_ = this.baseUrl + "/api/applications/{id}/finances/company/{statementCsv}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statementCsv === undefined || statementCsv === null)
            throw new Error("The parameter 'statementCsv' must be defined.");
        url_ = url_.replace("{statementCsv}", encodeURIComponent("" + statementCsv));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinances(<any>response_);
                } catch (e) {
                    return <Observable<CompanyFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinances(response: HttpResponseBase): Observable<CompanyFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no finance available for the loan", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyFinanceAC[]>(<any>null);
    }

    /**
     * Retrieve personal finances for a loan application
     * @param id Id of an application for which finances need to be fetched
     * @param scopeCsv Comma separated list of scopes of data to be fetched ex ["details","summary"]
     * @return Retrieved the finances
     */
    getPersonalFinances(id: string, scopeCsv: string | null): Observable<EntityAC[]> {
        let url_ = this.baseUrl + "/api/applications/{id}/finances/personal/{scopeCsv}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (scopeCsv === undefined || scopeCsv === null)
            throw new Error("The parameter 'scopeCsv' must be defined.");
        url_ = url_.replace("{scopeCsv}", encodeURIComponent("" + scopeCsv));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonalFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonalFinances(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonalFinances(response: HttpResponseBase): Observable<EntityAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no finance available for the loan", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC[]>(<any>null);
    }

    /**
     * Fetch credit report.
     * @param id Unique identifier for a loan application
     * @param entityId Unique identifier for entity
     * @return Successfully fetched and saved
     */
    fetchCreditReport(id: string, entityId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/applications/{id}/credit-report/{entityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCreditReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get credit report.
     * @param id Unique identifier for a loan application
     * @param entityId Unique identifier for entity
     * @return Retrieve the credit report
     */
    getCreditReport(id: string, entityId: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/credit-report/{entityId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreditReport(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Update the current section name
     * @param id Loan application id
     * @param currentSectionName Current Section Name
     * @return Returns the string of updated section name
     */
    updateCurrentSectionName(id: string, currentSectionName: string | null): Observable<string> {
        let url_ = this.baseUrl + "/api/applications/{id}/progress/{currentSectionName}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (currentSectionName === undefined || currentSectionName === null)
            throw new Error("The parameter 'currentSectionName' must be defined.");
        url_ = url_.replace("{currentSectionName}", encodeURIComponent("" + currentSectionName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrentSectionName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrentSectionName(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrentSectionName(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If the relevant data not found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Capture the consent of an entity for an application.
     * @param id Application id for which the user's consent needs to be saved
     * @return Returns the OK if the consent is saved successfully
     */
    saveLoanConsentOfUser(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/applications/{id}/consent";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLoanConsentOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLoanConsentOfUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLoanConsentOfUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the invalid application id is sent", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Lock the application with its details.
     * @param id Id of the loan application which needs to locked
     * @return Returns the OK if the loan application is locked successfully
     */
    lockLoanApplication(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/applications/{id}/lock";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLockLoanApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLockLoanApplication(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processLockLoanApplication(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the invalid application id is sent", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Evaluate loan and get loan status
     * @param id Loan application Id
     * @return Returns the OK if the loan application is evaluated successfully
     */
    evaluateLoanAndGetLoanStatus(id: string): Observable<ApplicationBasicDetailAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluateLoanAndGetLoanStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluateLoanAndGetLoanStatus(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(response_);
        }));
    }

    protected processEvaluateLoanAndGetLoanStatus(response: HttpResponseBase): Observable<ApplicationBasicDetailAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the application to evaluate is still not locked", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the invalid application id is sent", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationBasicDetailAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationBasicDetailAC>(<any>null);
    }

    /**
     * Update the loan application's status.
     * @param application Application basic details' object with updated values
     * @return Returns the status of successful update operation
     */
    updateLoanApplicationStatus(id: string, application: ApplicationBasicDetailAC): Observable<ApplicationBasicDetailAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(application);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanApplicationStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanApplicationStatus(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationBasicDetailAC>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanApplicationStatus(response: HttpResponseBase): Observable<ApplicationBasicDetailAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ApplicationBasicDetailAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationBasicDetailAC>(<any>null);
    }

    /**
     * Retrieve extracted value of document
     * @param id LoanApplication Id
     * @param documentId Document Id
     * @return Returns the list of TaxFormValueLabelMapping object
     */
    getDocumentExtractedValue(id: string, documentId: string): Observable<TaxFormValueLabelMappingAC[]> {
        let url_ = this.baseUrl + "/api/applications/{id}/documentExtractedValue/{documentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocumentExtractedValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocumentExtractedValue(<any>response_);
                } catch (e) {
                    return <Observable<TaxFormValueLabelMappingAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaxFormValueLabelMappingAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocumentExtractedValue(response: HttpResponseBase): Observable<TaxFormValueLabelMappingAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxFormValueLabelMappingAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("No relevant data found", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaxFormValueLabelMappingAC[]>(<any>null);
    }

    /**
     * Update the tax forms values related to the given application for entity
     * @param id Current application unique identifier
     * @param documentId Document unique identifier
     * @param taxFormValueLabelMappings List of updated taxFormValueLabelMappingAC object
     * @return Returns success code
     */
    updateTaxReturnValue(id: string, documentId: string, taxFormValueLabelMappings: TaxFormValueLabelMappingAC[]): Observable<TaxFormValueLabelMappingAC[]> {
        let url_ = this.baseUrl + "/api/applications/{id}/taxes/{documentId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(taxFormValueLabelMappings);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTaxReturnValue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTaxReturnValue(<any>response_);
                } catch (e) {
                    return <Observable<TaxFormValueLabelMappingAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<TaxFormValueLabelMappingAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTaxReturnValue(response: HttpResponseBase): Observable<TaxFormValueLabelMappingAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the object has invalid field or it is null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TaxFormValueLabelMappingAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TaxFormValueLabelMappingAC[]>(<any>null);
    }

    /**
     * Retrieve the loan application audit logs.
     * @param id Id of the loan application.
     * @return Returns the list of Audit logs
     */
    getAuditLogs(id: string): Observable<AuditDateWiseLogsAC[]> {
        let url_ = this.baseUrl + "/api/applications/{id}/activity-logs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditDateWiseLogsAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditDateWiseLogsAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<AuditDateWiseLogsAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditDateWiseLogsAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditDateWiseLogsAC[]>(<any>null);
    }

    /**
     * Retrieve the list of uploaded tax forms for the loan
     * @param id Application Id
     * @return Returns the list of tax forms linked with given loan
     */
    getTaxListByApplicationId(id: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/taxes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxListByApplicationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxListByApplicationId(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxListByApplicationId(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Retrieve the list of additional documents of a loan application
     * @param id Id of a loan application whose additional documents need to be fetched
     * @return Retrieved the additional documents
     */
    getAdditionalDocumentsForApplication(id: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/applications/{id}/additional-documents";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdditionalDocumentsForApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdditionalDocumentsForApplication(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdditionalDocumentsForApplication(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no required data available", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }
}

@Injectable()
export class EntityService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL_NEW) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    /**
     * Capture credit profile information.
     * @param entity Entity object
     * @return OkResult object
     */
    addUserCreditProfile(entity: EntityAC): Observable<boolean> {
        let url_ = this.baseUrl + "/api/entities/credit-profile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserCreditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserCreditProfile(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserCreditProfile(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null.", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Retrieve the list of loan applications.
     * @param id Id of an entity whose loan application list is to be retrived
     * @return Returns the list of applications linked with given entity
     */
    getLoanApplicationListByEntityId(id: string): Observable<ApplicationBasicDetailAC[]> {
        let url_ = this.baseUrl + "/api/entities/{id}/applications";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanApplicationListByEntityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanApplicationListByEntityId(<any>response_);
                } catch (e) {
                    return <Observable<ApplicationBasicDetailAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ApplicationBasicDetailAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanApplicationListByEntityId(response: HttpResponseBase): Observable<ApplicationBasicDetailAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ApplicationBasicDetailAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ApplicationBasicDetailAC[]>(<any>null);
    }

    /**
     * Check if entity has any open loan application.
     * @param entityId Unique identifier of entity object
     */
    checkEntityAllowToStartNewApplication(entityId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/entities/{entityId}/loans/draft";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckEntityAllowToStartNewApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckEntityAllowToStartNewApplication(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckEntityAllowToStartNewApplication(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Create an entity.
     * @param type Type of entity
     * @param entity Entity object
     * @return Returns the newly created entity object
     */
    addEntity(type: string | null, entity: EntityAC): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddEntity(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processAddEntity(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = EntityAC.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Update an entity.
     * @param id Unique identier for the entity object
     * @param entity Entity object
     */
    updateEntity(id: string, entity: EntityAC): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntity(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateEntity(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Remove an entity.
     * @param id Unique identier for the entity object
     * @param entity Unique identier for the entity object
     * @return Delete particular linking
     */
    removeLinkEntity(id: string, entity: EntityAC): Observable<void> {
        let url_ = this.baseUrl + "/api/entities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveLinkEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveLinkEntity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveLinkEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve an entity.
     * @param id Unique identier for the entity object
     * @return Retrieve an entity
     */
    getEntity(id: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntity(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntity(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Retrieve list of all entities.
     * @param pageNo (optional) Page number
     * @param pageRecordCount (optional) Page Record Count
     * @param filters (optional) 
     * @param filter (optional) Filter Object
    [{"field1","operator","value"},{"field2","operator","value"}]
     * @param sortField (optional) Field name for sorting.
     * @param sortBy (optional) Sorting option
     * @return Get list of entity
     */
    getEntityList(pageNo: number | null | undefined, pageRecordCount: number | null | undefined, filters: FilterAC[] | null | undefined, filter: string | null | undefined, sortField: string | null | undefined, sortBy: string | null | undefined): Observable<EntityAC[]> {
        let url_ = this.baseUrl + "/api/entities?";
        if (pageNo !== undefined && pageNo !== null)
            url_ += "PageNo=" + encodeURIComponent("" + pageNo) + "&";
        if (pageRecordCount !== undefined && pageRecordCount !== null)
            url_ += "PageRecordCount=" + encodeURIComponent("" + pageRecordCount) + "&";
        if (filters !== undefined && filters !== null)
            filters && filters.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Filters[" + index + "]." + attr + "=" + encodeURIComponent("" + (<any>item)[attr]) + "&";
        			}
            });
        if (filter !== undefined && filter !== null)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&";
        if (sortField !== undefined && sortField !== null)
            url_ += "SortField=" + encodeURIComponent("" + sortField) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEntityList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEntityList(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetEntityList(response: HttpResponseBase): Observable<EntityAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If user hasn\'t permission.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC[]>(<any>null);
    }

    /**
     * Retrieve Finances for a company
     * @param id Id of Entity for which financial information is needed
     * @param statementCsv Comma separated list of report names. Any of these ["Income Statement","Balance Sheet","Cash Flow","Financial Ratios"]
     * @return Retrieve the entity finances
     */
    getCompanyFinances(id: string, statementCsv: string | null): Observable<CompanyFinanceAC[]> {
        let url_ = this.baseUrl + "/api/entities/{id}/finances/company/{statementCsv}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statementCsv === undefined || statementCsv === null)
            throw new Error("The parameter 'statementCsv' must be defined.");
        url_ = url_.replace("{statementCsv}", encodeURIComponent("" + statementCsv));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyFinances(<any>response_);
                } catch (e) {
                    return <Observable<CompanyFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyFinances(response: HttpResponseBase): Observable<CompanyFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no finance available for the entity", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyFinanceAC[]>(<any>null);
    }

    /**
     * Add finances of company
     * @param id Id of entity for which finances are added
     * @param statementCsv Comma separated list of financial reports that are to be saved. Any of these ["Income Statement","Balance Sheet","Cash Flow","Financial Ratios"]
     * @param redirectCallbackData Metadata received with callback url of third party service like Quickbooks or Xero
     * @return Save entity finance
     */
    addCompanyFinances(id: string, statementCsv: string | null, redirectCallbackData: ThirdPartyServiceCallbackDataAC): Observable<void> {
        let url_ = this.baseUrl + "/api/entities/{id}/finances/company/{statementCsv}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (statementCsv === undefined || statementCsv === null)
            throw new Error("The parameter 'statementCsv' must be defined.");
        url_ = url_.replace("{statementCsv}", encodeURIComponent("" + statementCsv));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(redirectCallbackData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCompanyFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCompanyFinances(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddCompanyFinances(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve authorization url
     * @param id Id of entity, this will be used to feed in state variable of auth-url
     * @param source Name of third party service whose auth url is requested. Can be Quickbooks or Xero
     * @return Retrieve a constructed auth-url
     */
    getAuthUrl(id: string, source: string | null): Observable<string> {
        let url_ = this.baseUrl + "/api/entities/{id}/finances/{source}/auth-url";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (source === undefined || source === null)
            throw new Error("The parameter 'source' must be defined.");
        url_ = url_.replace("{source}", encodeURIComponent("" + source));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Add finances for Jamoon's standard accounts
     * @param id Id of entity for which standard finances are to be saved
     * @param siteSharedKey secret key that will be used by Lambda while invoking this API
     * @return Map third party finances data to standard accounts
     */
    mapFinances(id: string, siteSharedKey: string): Observable<void> {
        let url_ = this.baseUrl + "/api/entities/{id}/standard-statements";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(siteSharedKey);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMapFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMapFinances(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processMapFinances(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the request is not accessible", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("If the secret key is null", status, _responseText, _headers, result401);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve finances of a user
     * @param id Id of user whose finances need to be fetched
     * @param scopeCsv Comma separated list of scopes of data to be fetched. ["details","summary"]
     * @return Retrieved the personal finances
     */
    getPersonalFinances(id: string, scopeCsv: string | null): Observable<PersonalFinanceAC> {
        let url_ = this.baseUrl + "/api/entities/{id}/finances/personal/{scopeCsv}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (scopeCsv === undefined || scopeCsv === null)
            throw new Error("The parameter 'scopeCsv' must be defined.");
        url_ = url_.replace("{scopeCsv}", encodeURIComponent("" + scopeCsv));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPersonalFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPersonalFinances(<any>response_);
                } catch (e) {
                    return <Observable<PersonalFinanceAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<PersonalFinanceAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetPersonalFinances(response: HttpResponseBase): Observable<PersonalFinanceAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no required data available", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PersonalFinanceAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PersonalFinanceAC>(<any>null);
    }

    /**
     * Add finances of a user
     * @param id Id of an entity whose finances need to be added
     * @param category Finance category whose details need to be added
     * @return Added entity finance
     */
    addPersonalFinances(id: string, category: PersonalFinanceCategoryAC): Observable<void> {
        let url_ = this.baseUrl + "/api/entities/{id}/finances/personal";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddPersonalFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddPersonalFinances(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processAddPersonalFinances(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Update finances of a user
     * @param id Id of an entity whose finances need to be updated
     * @param category Finance category whose details need to be updated
     */
    updatePersonalFinances(id: string, category: PersonalFinanceCategoryAC): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{id}/finances/personal";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(category);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdatePersonalFinances(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdatePersonalFinances(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processUpdatePersonalFinances(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result204: any = null;
            let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result204 = EntityAC.fromJS(resultData204);
            return _observableOf(result204);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Retrieve the list of uploaded tax forms for the entity
     * @param id Entity Id
     * @return Returns the list of tax forms linked with given entity
     */
    getTaxListByEntityId(id: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{id}/taxes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxListByEntityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxListByEntityId(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxListByEntityId(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Capture the tax forms related to the given entity
     * @param id Id object
     * @param entityAC EntityAC object
     * @return Returns the newly created
     */
    addTaxForm(id: string, entityAC: EntityAC): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/entities/{id}/taxes";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entityAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTaxForm(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTaxForm(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAddTaxForm(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status === 201) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    /**
     * Fetch credit report.
     * @param id unique identifier of entity
     * @param application application object
     * @return Successfully fetched and saved
     */
    fetchCreditReport(id: string, application: ApplicationBasicDetailAC): Observable<void> {
        let url_ = this.baseUrl + "/api/entities/{id}/credit-report";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(application);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processFetchCreditReport(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Get credit report.
     * @param id unique identifier of entity
     * @return Retrieve the credit report
     */
    getCreditReport(id: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{id}/credit-report";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditReport(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreditReport(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Retrieve the entity audit logs.
     * @param id Entity Id.
     * @param auditLogFilter Audit log filter object.
     * @return Returns the list of Audit logs
     */
    getAuditLogs(id: string, auditLogFilter: AuditLogFilterAC): Observable<AuditDateWiseLogsAC[]> {
        let url_ = this.baseUrl + "/api/entities/{id}/activity-logs";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(auditLogFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogs(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogs(<any>response_);
                } catch (e) {
                    return <Observable<AuditDateWiseLogsAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditDateWiseLogsAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogs(response: HttpResponseBase): Observable<AuditDateWiseLogsAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid", status, _responseText, _headers, result400);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditDateWiseLogsAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditDateWiseLogsAC[]>(<any>null);
    }

    /**
     * Retrieve the list of additional documents of an entity
     * @param id Id of an entity whose additional documents need to be fetched
     * @return Retrieved the additional documents
     */
    getAdditionalDocumentsForEntity(id: string): Observable<EntityAC> {
        let url_ = this.baseUrl + "/api/entities/{id}/additional-documents";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdditionalDocumentsForEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdditionalDocumentsForEntity(<any>response_);
                } catch (e) {
                    return <Observable<EntityAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdditionalDocumentsForEntity(response: HttpResponseBase): Observable<EntityAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no required data available", status, _responseText, _headers);
            }));
        } else if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityAC>(<any>null);
    }

    /**
     * Add additional documents of an entity
     * @param id Id of an entity whose additional documents need to be added
     * @param entityAC Object of an entity, containing additional documents to add
     * @return Added entity finance
     */
    saveAdditionalDocumentsForEntity(id: string, entityAC: EntityAC): Observable<void> {
        let url_ = this.baseUrl + "/api/entities/{id}/additional-documents";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entityAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAdditionalDocumentsForEntity(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAdditionalDocumentsForEntity(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAdditionalDocumentsForEntity(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("If the user haven\'t permission to access the request", status, _responseText, _headers, result403);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class GlobalService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL_NEW) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    /**
     * Fetch the list of consent statements.
     * @return Returns the list of ConsentStatementAC objects
     */
    getConsentStatements(): Observable<ConsentStatementAC[]> {
        let url_ = this.baseUrl + "/api/common/consents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsentStatements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsentStatements(<any>response_);
                } catch (e) {
                    return <Observable<ConsentStatementAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsentStatementAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsentStatements(response: HttpResponseBase): Observable<ConsentStatementAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsentStatementAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsentStatementAC[]>(<any>null);
    }

    /**
     * Fetch the list of banks.
     * @return Returns the list of BankAC objects
     */
    getListOfBanks(): Observable<BankAC[]> {
        let url_ = this.baseUrl + "/api/common/banks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfBanks(<any>response_);
                } catch (e) {
                    return <Observable<BankAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfBanks(response: HttpResponseBase): Observable<BankAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAC[]>(<any>null);
    }

    /**
     * Fetch the list of loan purposes.
     * @return Returns the list of LoanPurposeAC objects
     */
    getLoanPurposeList(): Observable<LoanPurposeAC[]> {
        let url_ = this.baseUrl + "/api/common/loan-purposes";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanPurposeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanPurposeList(<any>response_);
                } catch (e) {
                    return <Observable<LoanPurposeAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanPurposeAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanPurposeList(response: HttpResponseBase): Observable<LoanPurposeAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LoanPurposeAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanPurposeAC[]>(<any>null);
    }

    /**
     * Fetch all the configurations required for UI.
     * @return Returns the list of BankAC objects
     */
    getConfigurations(): Observable<ConfigurationAC> {
        let url_ = this.baseUrl + "/api/common/configurations";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConfigurations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConfigurations(<any>response_);
                } catch (e) {
                    return <Observable<ConfigurationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConfigurationAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetConfigurations(response: HttpResponseBase): Observable<ConfigurationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ConfigurationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConfigurationAC>(<any>null);
    }

    /**
     * Retrieve list of Company age ranges.
     * @return Returns the list of company age ranges
     */
    getBusinessAgeRangeList(): Observable<BusinessAgeAC[]> {
        let url_ = this.baseUrl + "/api/common/company/age-ranges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBusinessAgeRangeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBusinessAgeRangeList(<any>response_);
                } catch (e) {
                    return <Observable<BusinessAgeAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BusinessAgeAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBusinessAgeRangeList(response: HttpResponseBase): Observable<BusinessAgeAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BusinessAgeAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BusinessAgeAC[]>(<any>null);
    }

    /**
     * Retrieve list of Company types.
     * @return Returns the list of company structure
     */
    getCompanyStructureList(): Observable<CompanyStructureAC[]> {
        let url_ = this.baseUrl + "/api/common/company/types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyStructureList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyStructureList(<any>response_);
                } catch (e) {
                    return <Observable<CompanyStructureAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyStructureAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyStructureList(response: HttpResponseBase): Observable<CompanyStructureAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyStructureAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyStructureAC[]>(<any>null);
    }

    /**
     * Retrieve list of Company size ranges.
     * @return Returns the list of company size ranges
     */
    getCompanySizeList(): Observable<CompanySizeAC[]> {
        let url_ = this.baseUrl + "/api/common/company/size-ranges";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanySizeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanySizeList(<any>response_);
                } catch (e) {
                    return <Observable<CompanySizeAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanySizeAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanySizeList(response: HttpResponseBase): Observable<CompanySizeAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanySizeAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanySizeAC[]>(<any>null);
    }

    /**
     * Retrieve list of Industry group.
     * @return Returns the list of industry group
     */
    getIndustryGroupList(): Observable<NAICSIndustryType[]> {
        let url_ = this.baseUrl + "/api/common/industry-group";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustryGroupList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustryGroupList(<any>response_);
                } catch (e) {
                    return <Observable<NAICSIndustryType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<NAICSIndustryType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustryGroupList(response: HttpResponseBase): Observable<NAICSIndustryType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(NAICSIndustryType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<NAICSIndustryType[]>(<any>null);
    }

    /**
     * Retrieve list of Industry Experiences.
     * @return Returns the list of Industry Experiences
     */
    getIndustryExperienceList(): Observable<IndustryExperienceAC[]> {
        let url_ = this.baseUrl + "/api/common/company/industry-experience";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetIndustryExperienceList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetIndustryExperienceList(<any>response_);
                } catch (e) {
                    return <Observable<IndustryExperienceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<IndustryExperienceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetIndustryExperienceList(response: HttpResponseBase): Observable<IndustryExperienceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IndustryExperienceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<IndustryExperienceAC[]>(<any>null);
    }

    /**
     * Fetch the list of additional document types.
     * @return Returns the list of AdditionalDocumentTypeAC objects
     */
    getAdditionalDocumentTypes(): Observable<AdditionalDocumentTypeAC[]> {
        let url_ = this.baseUrl + "/api/common/additional-document-types";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdditionalDocumentTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdditionalDocumentTypes(<any>response_);
                } catch (e) {
                    return <Observable<AdditionalDocumentTypeAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AdditionalDocumentTypeAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdditionalDocumentTypes(response: HttpResponseBase): Observable<AdditionalDocumentTypeAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AdditionalDocumentTypeAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("If there is no finance available for the entity", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AdditionalDocumentTypeAC[]>(<any>null);
    }

    /**
     * Get document pre-signed url for the download purpose
     * @param id Document Id
     * @return Generated Pre-Signed URL link
     */
    getDocument(id: string): Observable<string> {
        let url_ = this.baseUrl + "/api/common/download-file/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocument(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocument(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid or null", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    /**
     * Get upload presigned URL
     * @param fileName name of the file to be uploaded.
     * @return Returns upload presigned URL.
     */
    getUploadPreSignedURL(fileName: string | null): Observable<AwsSettings> {
        let url_ = this.baseUrl + "/api/common/upload-presignedURL/{fileName}";
        if (fileName === undefined || fileName === null)
            throw new Error("The parameter 'fileName' must be defined.");
        url_ = url_.replace("{fileName}", encodeURIComponent("" + fileName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUploadPreSignedURL(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUploadPreSignedURL(<any>response_);
                } catch (e) {
                    return <Observable<AwsSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwsSettings>><any>_observableThrow(response_);
        }));
    }

    protected processGetUploadPreSignedURL(response: HttpResponseBase): Observable<AwsSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwsSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwsSettings>(<any>null);
    }

    /**
     * Retrieve the list of fields of the log by field primary key of the old value and old value.
     * @param auditLogField Field object.
     * @return Returns the list of fields of the log.
     */
    getAuditLogByPkId(auditLogField: AuditLogFieldAC): Observable<AuditLogFieldAC[]> {
        let url_ = this.baseUrl + "/api/common/activity-log";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(auditLogField);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditLogByPkId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditLogByPkId(<any>response_);
                } catch (e) {
                    return <Observable<AuditLogFieldAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuditLogFieldAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditLogByPkId(response: HttpResponseBase): Observable<AuditLogFieldAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(AuditLogFieldAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("If the request parameter is invalid.", status, _responseText, _headers, result400);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("Activity log is not exist in the system.", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuditLogFieldAC[]>(<any>null);
    }
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        this.extensions![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    data["extensions"][key] = this.extensions[key];
            }
        }
        return data; 
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions?: { [key: string]: any; } | undefined;
}

export class PagedLoanApplicationsAC implements IPagedLoanApplicationsAC {
    /** Count of total applications. */
    totalApplicationsCount!: number;
    /** List of applications (after paging/filetring/sorting). */
    applications?: ApplicationAC[] | undefined;

    constructor(data?: IPagedLoanApplicationsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalApplicationsCount = _data["totalApplicationsCount"];
            if (Array.isArray(_data["applications"])) {
                this.applications = [] as any;
                for (let item of _data["applications"])
                    this.applications!.push(ApplicationAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedLoanApplicationsAC {
        data = typeof data === 'object' ? data : {};
        let result = new PagedLoanApplicationsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalApplicationsCount"] = this.totalApplicationsCount;
        if (Array.isArray(this.applications)) {
            data["applications"] = [];
            for (let item of this.applications)
                data["applications"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPagedLoanApplicationsAC {
    /** Count of total applications. */
    totalApplicationsCount: number;
    /** List of applications (after paging/filetring/sorting). */
    applications?: ApplicationAC[] | undefined;
}

export class ApplicationAC implements IApplicationAC {
    /** The application's basic detail */
    basicDetails?: ApplicationBasicDetailAC | undefined;
    /** List of all the borrowing entities details. */
    borrowingEntities?: EntityAC[] | undefined;
    /** The selected product's detail. */
    selectedProduct?: RecommendedProductAC | undefined;

    constructor(data?: IApplicationAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.basicDetails = _data["basicDetails"] ? ApplicationBasicDetailAC.fromJS(_data["basicDetails"]) : <any>undefined;
            if (Array.isArray(_data["borrowingEntities"])) {
                this.borrowingEntities = [] as any;
                for (let item of _data["borrowingEntities"])
                    this.borrowingEntities!.push(EntityAC.fromJS(item));
            }
            this.selectedProduct = _data["selectedProduct"] ? RecommendedProductAC.fromJS(_data["selectedProduct"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ApplicationAC {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["basicDetails"] = this.basicDetails ? this.basicDetails.toJSON() : <any>undefined;
        if (Array.isArray(this.borrowingEntities)) {
            data["borrowingEntities"] = [];
            for (let item of this.borrowingEntities)
                data["borrowingEntities"].push(item.toJSON());
        }
        data["selectedProduct"] = this.selectedProduct ? this.selectedProduct.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IApplicationAC {
    /** The application's basic detail */
    basicDetails?: ApplicationBasicDetailAC | undefined;
    /** List of all the borrowing entities details. */
    borrowingEntities?: EntityAC[] | undefined;
    /** The selected product's detail. */
    selectedProduct?: RecommendedProductAC | undefined;
}

export class ApplicationBasicDetailAC implements IApplicationBasicDetailAC {
    /** Unique identifier for application */
    id?: string | undefined;
    /** Application number assigned to particular application. */
    loanApplicationNumber?: string | undefined;
    /** Unique identifier for the entity object who initiated application. */
    entityId!: string;
    /** Loan Amount of the application. */
    loanAmount!: number;
    /** Unique identifier for Loan Purpose object. */
    loanPurposeId!: string;
    /** Unique identifier for Sub Loan Purpose object. */
    subLoanPurposeId!: string;
    /** Time period of loan */
    loanPeriod!: number;
    /** Current status of the application. */
    status!: LoanApplicationStatusType;
    /** Current section the application is in. */
    sectionName?: string | undefined;
    /** Application creation date. */
    createdOn!: Date;
    /** Application updation date. */
    updatedOn?: Date | undefined;
    /** Data output from rule engine during rule evaluation */
    evaluationComments?: string | undefined;
    /** Interest rate based on self declared credit score of loan initiator. */
    interestRate?: number | undefined;
    /** Details of Bank user who updated the application. */
    updatedByBankUser?: BankUser | undefined;
    /** Is application in view only mode or not */
    isReadOnlyMode!: boolean;
    /** Entity's bank details for the application */
    entityBankDetails?: LoanEntityBankDetailsAC | undefined;
    /** Date on which the application is last updated */
    lastUpdatedOn?: Date | undefined;
    /** Unique identifier of entity if it is mapped */
    mappedEntityId!: string;
    /** Unique identifier for entity user (Loan initiator) */
    createdByUserId!: string;

    constructor(data?: IApplicationBasicDetailAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanApplicationNumber = _data["loanApplicationNumber"];
            this.entityId = _data["entityId"];
            this.loanAmount = _data["loanAmount"];
            this.loanPurposeId = _data["loanPurposeId"];
            this.subLoanPurposeId = _data["subLoanPurposeId"];
            this.loanPeriod = _data["loanPeriod"];
            this.status = _data["status"];
            this.sectionName = _data["sectionName"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.evaluationComments = _data["evaluationComments"];
            this.interestRate = _data["interestRate"];
            this.updatedByBankUser = _data["updatedByBankUser"] ? BankUser.fromJS(_data["updatedByBankUser"]) : <any>undefined;
            this.isReadOnlyMode = _data["isReadOnlyMode"];
            this.entityBankDetails = _data["entityBankDetails"] ? LoanEntityBankDetailsAC.fromJS(_data["entityBankDetails"]) : <any>undefined;
            this.lastUpdatedOn = _data["lastUpdatedOn"] ? new Date(_data["lastUpdatedOn"].toString()) : <any>undefined;
            this.mappedEntityId = _data["mappedEntityId"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): ApplicationBasicDetailAC {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationBasicDetailAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanApplicationNumber"] = this.loanApplicationNumber;
        data["entityId"] = this.entityId;
        data["loanAmount"] = this.loanAmount;
        data["loanPurposeId"] = this.loanPurposeId;
        data["subLoanPurposeId"] = this.subLoanPurposeId;
        data["loanPeriod"] = this.loanPeriod;
        data["status"] = this.status;
        data["sectionName"] = this.sectionName;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["evaluationComments"] = this.evaluationComments;
        data["interestRate"] = this.interestRate;
        data["updatedByBankUser"] = this.updatedByBankUser ? this.updatedByBankUser.toJSON() : <any>undefined;
        data["isReadOnlyMode"] = this.isReadOnlyMode;
        data["entityBankDetails"] = this.entityBankDetails ? this.entityBankDetails.toJSON() : <any>undefined;
        data["lastUpdatedOn"] = this.lastUpdatedOn ? this.lastUpdatedOn.toISOString() : <any>undefined;
        data["mappedEntityId"] = this.mappedEntityId;
        data["createdByUserId"] = this.createdByUserId;
        return data; 
    }
}

export interface IApplicationBasicDetailAC {
    /** Unique identifier for application */
    id?: string | undefined;
    /** Application number assigned to particular application. */
    loanApplicationNumber?: string | undefined;
    /** Unique identifier for the entity object who initiated application. */
    entityId: string;
    /** Loan Amount of the application. */
    loanAmount: number;
    /** Unique identifier for Loan Purpose object. */
    loanPurposeId: string;
    /** Unique identifier for Sub Loan Purpose object. */
    subLoanPurposeId: string;
    /** Time period of loan */
    loanPeriod: number;
    /** Current status of the application. */
    status: LoanApplicationStatusType;
    /** Current section the application is in. */
    sectionName?: string | undefined;
    /** Application creation date. */
    createdOn: Date;
    /** Application updation date. */
    updatedOn?: Date | undefined;
    /** Data output from rule engine during rule evaluation */
    evaluationComments?: string | undefined;
    /** Interest rate based on self declared credit score of loan initiator. */
    interestRate?: number | undefined;
    /** Details of Bank user who updated the application. */
    updatedByBankUser?: BankUser | undefined;
    /** Is application in view only mode or not */
    isReadOnlyMode: boolean;
    /** Entity's bank details for the application */
    entityBankDetails?: LoanEntityBankDetailsAC | undefined;
    /** Date on which the application is last updated */
    lastUpdatedOn?: Date | undefined;
    /** Unique identifier of entity if it is mapped */
    mappedEntityId: string;
    /** Unique identifier for entity user (Loan initiator) */
    createdByUserId: string;
}

export enum LoanApplicationStatusType {
    Draft = 0,
    Locked = 1,
    Unlocked = 2,
    Approved = 3,
    Rejected = 4,
    Referral = 5,
    EvaluationFailure = 6,
}

export class BankUser implements IBankUser {
    id!: string;
    name?: string | undefined;
    email!: string;
    phone?: string | undefined;

    constructor(data?: IBankUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.phone = _data["phone"];
        }
    }

    static fromJS(data: any): BankUser {
        data = typeof data === 'object' ? data : {};
        let result = new BankUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["phone"] = this.phone;
        return data; 
    }
}

export interface IBankUser {
    id: string;
    name?: string | undefined;
    email: string;
    phone?: string | undefined;
}

export class LoanEntityBankDetailsAC implements ILoanEntityBankDetailsAC {
    /** Unique identifier of the loan application for which bank details are to be saved. */
    loanApplicationId!: string;
    /** Bank details of the account in which loan amount will be transferred. */
    loanAmountDepositeeBank?: EntityBankDetailsAC | undefined;
    /** Bank details of the account from which EMI will be deducted. */
    emiDeducteeBank?: EntityBankDetailsAC | undefined;

    constructor(data?: ILoanEntityBankDetailsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanApplicationId = _data["loanApplicationId"];
            this.loanAmountDepositeeBank = _data["loanAmountDepositeeBank"] ? EntityBankDetailsAC.fromJS(_data["loanAmountDepositeeBank"]) : <any>undefined;
            this.emiDeducteeBank = _data["emiDeducteeBank"] ? EntityBankDetailsAC.fromJS(_data["emiDeducteeBank"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoanEntityBankDetailsAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanEntityBankDetailsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanApplicationId"] = this.loanApplicationId;
        data["loanAmountDepositeeBank"] = this.loanAmountDepositeeBank ? this.loanAmountDepositeeBank.toJSON() : <any>undefined;
        data["emiDeducteeBank"] = this.emiDeducteeBank ? this.emiDeducteeBank.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILoanEntityBankDetailsAC {
    /** Unique identifier of the loan application for which bank details are to be saved. */
    loanApplicationId: string;
    /** Bank details of the account in which loan amount will be transferred. */
    loanAmountDepositeeBank?: EntityBankDetailsAC | undefined;
    /** Bank details of the account from which EMI will be deducted. */
    emiDeducteeBank?: EntityBankDetailsAC | undefined;
}

export class EntityBankDetailsAC implements IEntityBankDetailsAC {
    /** Unique identifier for the Bank. */
    bankId!: string;
    /** Entity's account number. */
    accountNumber?: string | undefined;
    /** Name of the bank. */
    bankName?: string | undefined;
    /** SWIFT code of the bank. */
    swiftCode?: string | undefined;

    constructor(data?: IEntityBankDetailsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankId = _data["bankId"];
            this.accountNumber = _data["accountNumber"];
            this.bankName = _data["bankName"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static fromJS(data: any): EntityBankDetailsAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityBankDetailsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankId"] = this.bankId;
        data["accountNumber"] = this.accountNumber;
        data["bankName"] = this.bankName;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IEntityBankDetailsAC {
    /** Unique identifier for the Bank. */
    bankId: string;
    /** Entity's account number. */
    accountNumber?: string | undefined;
    /** Name of the bank. */
    bankName?: string | undefined;
    /** SWIFT code of the bank. */
    swiftCode?: string | undefined;
}

export class EntityAC implements IEntityAC {
    /** Unique identifier for the entity object */
    id?: string | undefined;
    /** Entity type details */
    type?: EntityType | undefined;
    /** Address details of entity */
    address?: AddressAC | undefined;
    /** User details */
    user?: UserAC | undefined;
    /** Company details */
    company?: CompanyAC | undefined;
    /** List of linked entities */
    linkedEntities?: EntityAC[] | undefined;
    /** List of company finances */
    companyFinances?: CompanyFinanceAC[] | undefined;
    /** Personal finances of entity */
    personalFinance?: PersonalFinanceAC | undefined;
    /** Credit report details */
    creditReport?: CreditReportAC | undefined;
    /** Consent details */
    consents?: ConsentAC[] | undefined;
    /** List of taxes related to entity */
    taxes?: TaxAC[] | undefined;
    /** List of additional documents of entity */
    additionalDocuments?: AdditionalDocumentAC[] | undefined;
    /** List of all finance and tax years  */
    periods?: string[] | undefined;
    relationMapping?: EntityRelationMappingAC | undefined;
    /** It's loan id. It's used to track the log details of the loan. */
    loanId?: string | undefined;

    constructor(data?: IEntityAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.address = _data["address"] ? AddressAC.fromJS(_data["address"]) : <any>undefined;
            this.user = _data["user"] ? UserAC.fromJS(_data["user"]) : <any>undefined;
            this.company = _data["company"] ? CompanyAC.fromJS(_data["company"]) : <any>undefined;
            if (Array.isArray(_data["linkedEntities"])) {
                this.linkedEntities = [] as any;
                for (let item of _data["linkedEntities"])
                    this.linkedEntities!.push(EntityAC.fromJS(item));
            }
            if (Array.isArray(_data["companyFinances"])) {
                this.companyFinances = [] as any;
                for (let item of _data["companyFinances"])
                    this.companyFinances!.push(CompanyFinanceAC.fromJS(item));
            }
            this.personalFinance = _data["personalFinance"] ? PersonalFinanceAC.fromJS(_data["personalFinance"]) : <any>undefined;
            this.creditReport = _data["creditReport"] ? CreditReportAC.fromJS(_data["creditReport"]) : <any>undefined;
            if (Array.isArray(_data["consents"])) {
                this.consents = [] as any;
                for (let item of _data["consents"])
                    this.consents!.push(ConsentAC.fromJS(item));
            }
            if (Array.isArray(_data["taxes"])) {
                this.taxes = [] as any;
                for (let item of _data["taxes"])
                    this.taxes!.push(TaxAC.fromJS(item));
            }
            if (Array.isArray(_data["additionalDocuments"])) {
                this.additionalDocuments = [] as any;
                for (let item of _data["additionalDocuments"])
                    this.additionalDocuments!.push(AdditionalDocumentAC.fromJS(item));
            }
            if (Array.isArray(_data["periods"])) {
                this.periods = [] as any;
                for (let item of _data["periods"])
                    this.periods!.push(item);
            }
            this.relationMapping = _data["relationMapping"] ? EntityRelationMappingAC.fromJS(_data["relationMapping"]) : <any>undefined;
            this.loanId = _data["loanId"];
        }
    }

    static fromJS(data: any): EntityAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["company"] = this.company ? this.company.toJSON() : <any>undefined;
        if (Array.isArray(this.linkedEntities)) {
            data["linkedEntities"] = [];
            for (let item of this.linkedEntities)
                data["linkedEntities"].push(item.toJSON());
        }
        if (Array.isArray(this.companyFinances)) {
            data["companyFinances"] = [];
            for (let item of this.companyFinances)
                data["companyFinances"].push(item.toJSON());
        }
        data["personalFinance"] = this.personalFinance ? this.personalFinance.toJSON() : <any>undefined;
        data["creditReport"] = this.creditReport ? this.creditReport.toJSON() : <any>undefined;
        if (Array.isArray(this.consents)) {
            data["consents"] = [];
            for (let item of this.consents)
                data["consents"].push(item.toJSON());
        }
        if (Array.isArray(this.taxes)) {
            data["taxes"] = [];
            for (let item of this.taxes)
                data["taxes"].push(item.toJSON());
        }
        if (Array.isArray(this.additionalDocuments)) {
            data["additionalDocuments"] = [];
            for (let item of this.additionalDocuments)
                data["additionalDocuments"].push(item.toJSON());
        }
        if (Array.isArray(this.periods)) {
            data["periods"] = [];
            for (let item of this.periods)
                data["periods"].push(item);
        }
        data["relationMapping"] = this.relationMapping ? this.relationMapping.toJSON() : <any>undefined;
        data["loanId"] = this.loanId;
        return data; 
    }
}

export interface IEntityAC {
    /** Unique identifier for the entity object */
    id?: string | undefined;
    /** Entity type details */
    type?: EntityType | undefined;
    /** Address details of entity */
    address?: AddressAC | undefined;
    /** User details */
    user?: UserAC | undefined;
    /** Company details */
    company?: CompanyAC | undefined;
    /** List of linked entities */
    linkedEntities?: EntityAC[] | undefined;
    /** List of company finances */
    companyFinances?: CompanyFinanceAC[] | undefined;
    /** Personal finances of entity */
    personalFinance?: PersonalFinanceAC | undefined;
    /** Credit report details */
    creditReport?: CreditReportAC | undefined;
    /** Consent details */
    consents?: ConsentAC[] | undefined;
    /** List of taxes related to entity */
    taxes?: TaxAC[] | undefined;
    /** List of additional documents of entity */
    additionalDocuments?: AdditionalDocumentAC[] | undefined;
    /** List of all finance and tax years  */
    periods?: string[] | undefined;
    relationMapping?: EntityRelationMappingAC | undefined;
    /** It's loan id. It's used to track the log details of the loan. */
    loanId?: string | undefined;
}

export enum EntityType {
    Company = 0,
    User = 1,
}

export class AddressAC implements IAddressAC {
    id?: string | undefined;
    primaryNumber?: string | undefined;
    streetLine?: string | undefined;
    city?: string | undefined;
    stateAbbreviation?: string | undefined;
    streetSuffix?: string | undefined;
    secondaryNumber?: string | undefined;
    secondaryDesignator?: string | undefined;
    zipCode?: string | undefined;
    addressJson?: string | undefined;
    integratedServiceConfigurationId?: string | undefined;
    addressSuggestion?: any[] | undefined;

    constructor(data?: IAddressAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.primaryNumber = _data["primaryNumber"];
            this.streetLine = _data["streetLine"];
            this.city = _data["city"];
            this.stateAbbreviation = _data["stateAbbreviation"];
            this.streetSuffix = _data["streetSuffix"];
            this.secondaryNumber = _data["secondaryNumber"];
            this.secondaryDesignator = _data["secondaryDesignator"];
            this.zipCode = _data["zipCode"];
            this.addressJson = _data["addressJson"];
            this.integratedServiceConfigurationId = _data["integratedServiceConfigurationId"];
            if (Array.isArray(_data["addressSuggestion"])) {
                this.addressSuggestion = [] as any;
                for (let item of _data["addressSuggestion"])
                    this.addressSuggestion!.push(item);
            }
        }
    }

    static fromJS(data: any): AddressAC {
        data = typeof data === 'object' ? data : {};
        let result = new AddressAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["primaryNumber"] = this.primaryNumber;
        data["streetLine"] = this.streetLine;
        data["city"] = this.city;
        data["stateAbbreviation"] = this.stateAbbreviation;
        data["streetSuffix"] = this.streetSuffix;
        data["secondaryNumber"] = this.secondaryNumber;
        data["secondaryDesignator"] = this.secondaryDesignator;
        data["zipCode"] = this.zipCode;
        data["addressJson"] = this.addressJson;
        data["integratedServiceConfigurationId"] = this.integratedServiceConfigurationId;
        if (Array.isArray(this.addressSuggestion)) {
            data["addressSuggestion"] = [];
            for (let item of this.addressSuggestion)
                data["addressSuggestion"].push(item);
        }
        return data; 
    }
}

export interface IAddressAC {
    id?: string | undefined;
    primaryNumber?: string | undefined;
    streetLine?: string | undefined;
    city?: string | undefined;
    stateAbbreviation?: string | undefined;
    streetSuffix?: string | undefined;
    secondaryNumber?: string | undefined;
    secondaryDesignator?: string | undefined;
    zipCode?: string | undefined;
    addressJson?: string | undefined;
    integratedServiceConfigurationId?: string | undefined;
    addressSuggestion?: any[] | undefined;
}

export class UserAC implements IUserAC {
    /** First Name of the user */
    firstName?: string | undefined;
    /** Middle Name of the user */
    middleName?: string | undefined;
    /** Last Name of the user */
    lastName?: string | undefined;
    /** Email of the user */
    email!: string;
    /** SSN of the user */
    ssn?: string | undefined;
    /** Valid phone number of the user */
    phone?: string | undefined;
    /** Date of birth of the user */
    dob?: Date | undefined;
    /** ResidencyStatus of User */
    residencyStatus?: ResidencyStatus | undefined;
    /** User self declared credit score in range eg. 100-250. */
    selfDeclaredCreditScore?: string | undefined;
    /** If user has any bankruptcy in the past years. */
    hasBankruptcySelfDeclared?: boolean | undefined;
    /** If user has any jugements in the past months. */
    hasAnyJudgementsSelfDeclared?: boolean | undefined;

    constructor(data?: IUserAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.middleName = _data["middleName"];
            this.lastName = _data["lastName"];
            this.email = _data["email"];
            this.ssn = _data["ssn"];
            this.phone = _data["phone"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
            this.residencyStatus = _data["residencyStatus"];
            this.selfDeclaredCreditScore = _data["selfDeclaredCreditScore"];
            this.hasBankruptcySelfDeclared = _data["hasBankruptcySelfDeclared"];
            this.hasAnyJudgementsSelfDeclared = _data["hasAnyJudgementsSelfDeclared"];
        }
    }

    static fromJS(data: any): UserAC {
        data = typeof data === 'object' ? data : {};
        let result = new UserAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["middleName"] = this.middleName;
        data["lastName"] = this.lastName;
        data["email"] = this.email;
        data["ssn"] = this.ssn;
        data["phone"] = this.phone;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        data["residencyStatus"] = this.residencyStatus;
        data["selfDeclaredCreditScore"] = this.selfDeclaredCreditScore;
        data["hasBankruptcySelfDeclared"] = this.hasBankruptcySelfDeclared;
        data["hasAnyJudgementsSelfDeclared"] = this.hasAnyJudgementsSelfDeclared;
        return data; 
    }
}

export interface IUserAC {
    /** First Name of the user */
    firstName?: string | undefined;
    /** Middle Name of the user */
    middleName?: string | undefined;
    /** Last Name of the user */
    lastName?: string | undefined;
    /** Email of the user */
    email: string;
    /** SSN of the user */
    ssn?: string | undefined;
    /** Valid phone number of the user */
    phone?: string | undefined;
    /** Date of birth of the user */
    dob?: Date | undefined;
    /** ResidencyStatus of User */
    residencyStatus?: ResidencyStatus | undefined;
    /** User self declared credit score in range eg. 100-250. */
    selfDeclaredCreditScore?: string | undefined;
    /** If user has any bankruptcy in the past years. */
    hasBankruptcySelfDeclared?: boolean | undefined;
    /** If user has any jugements in the past months. */
    hasAnyJudgementsSelfDeclared?: boolean | undefined;
}

export enum ResidencyStatus {
    USCitizen = 0,
    USPermanentResident = 1,
    NonResident = 2,
}

export class CompanyAC implements ICompanyAC {
    /** Name of the company. */
    name!: string;
    /** Personal SSN for propietorship or company EIN for other company structure. */
    cin!: string;
    /** The company type details */
    companyStructure!: CompanyStructureAC;
    /** Company Age Deteails */
    businessAge!: BusinessAgeAC;
    /** Company size details */
    companySize!: CompanySizeAC;
    /** Industry Type details */
    industryType!: IndustryTypeAC;
    /** Industry Experience details */
    industryExperience!: IndustryExperienceAC;
    /** Company registered state location */
    companyRegisteredState?: string | undefined;
    /** Is Company's Fiscal Year Same as Calender */
    companyFiscalYearStartMonth?: number | undefined;
    /** Unique identifier for creator(entity) of the company. */
    createdByUserId?: string | undefined;

    constructor(data?: ICompanyAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.companyStructure = new CompanyStructureAC();
            this.businessAge = new BusinessAgeAC();
            this.companySize = new CompanySizeAC();
            this.industryType = new IndustryTypeAC();
            this.industryExperience = new IndustryExperienceAC();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.cin = _data["cin"];
            this.companyStructure = _data["companyStructure"] ? CompanyStructureAC.fromJS(_data["companyStructure"]) : new CompanyStructureAC();
            this.businessAge = _data["businessAge"] ? BusinessAgeAC.fromJS(_data["businessAge"]) : new BusinessAgeAC();
            this.companySize = _data["companySize"] ? CompanySizeAC.fromJS(_data["companySize"]) : new CompanySizeAC();
            this.industryType = _data["industryType"] ? IndustryTypeAC.fromJS(_data["industryType"]) : new IndustryTypeAC();
            this.industryExperience = _data["industryExperience"] ? IndustryExperienceAC.fromJS(_data["industryExperience"]) : new IndustryExperienceAC();
            this.companyRegisteredState = _data["companyRegisteredState"];
            this.companyFiscalYearStartMonth = _data["companyFiscalYearStartMonth"];
            this.createdByUserId = _data["createdByUserId"];
        }
    }

    static fromJS(data: any): CompanyAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["cin"] = this.cin;
        data["companyStructure"] = this.companyStructure ? this.companyStructure.toJSON() : <any>undefined;
        data["businessAge"] = this.businessAge ? this.businessAge.toJSON() : <any>undefined;
        data["companySize"] = this.companySize ? this.companySize.toJSON() : <any>undefined;
        data["industryType"] = this.industryType ? this.industryType.toJSON() : <any>undefined;
        data["industryExperience"] = this.industryExperience ? this.industryExperience.toJSON() : <any>undefined;
        data["companyRegisteredState"] = this.companyRegisteredState;
        data["companyFiscalYearStartMonth"] = this.companyFiscalYearStartMonth;
        data["createdByUserId"] = this.createdByUserId;
        return data; 
    }
}

export interface ICompanyAC {
    /** Name of the company. */
    name: string;
    /** Personal SSN for propietorship or company EIN for other company structure. */
    cin: string;
    /** The company type details */
    companyStructure: CompanyStructureAC;
    /** Company Age Deteails */
    businessAge: BusinessAgeAC;
    /** Company size details */
    companySize: CompanySizeAC;
    /** Industry Type details */
    industryType: IndustryTypeAC;
    /** Industry Experience details */
    industryExperience: IndustryExperienceAC;
    /** Company registered state location */
    companyRegisteredState?: string | undefined;
    /** Is Company's Fiscal Year Same as Calender */
    companyFiscalYearStartMonth?: number | undefined;
    /** Unique identifier for creator(entity) of the company. */
    createdByUserId?: string | undefined;
}

export class CompanyStructureAC implements ICompanyStructureAC {
    /** Unique identifier for the company type object. */
    id!: string;
    /** Company Type. */
    structure?: string | undefined;
    /** Order number for sequence. */
    order?: number | undefined;

    constructor(data?: ICompanyStructureAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.structure = _data["structure"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CompanyStructureAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyStructureAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["structure"] = this.structure;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICompanyStructureAC {
    /** Unique identifier for the company type object. */
    id: string;
    /** Company Type. */
    structure?: string | undefined;
    /** Order number for sequence. */
    order?: number | undefined;
}

export class BusinessAgeAC implements IBusinessAgeAC {
    /** Unique identifier for the company age object */
    id!: string;
    /** Age of the company */
    age?: string | undefined;
    /** Order number for sequence */
    order?: number | undefined;

    constructor(data?: IBusinessAgeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.age = _data["age"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): BusinessAgeAC {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAgeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["age"] = this.age;
        data["order"] = this.order;
        return data; 
    }
}

export interface IBusinessAgeAC {
    /** Unique identifier for the company age object */
    id: string;
    /** Age of the company */
    age?: string | undefined;
    /** Order number for sequence */
    order?: number | undefined;
}

export class CompanySizeAC implements ICompanySizeAC {
    /** Unique identifier for the company size object */
    id!: string;
    /** Size of the company */
    size?: string | undefined;
    /** Order number for sequence */
    order?: number | undefined;
    /** Is option enabled */
    isEnabled!: boolean;

    constructor(data?: ICompanySizeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.size = _data["size"];
            this.order = _data["order"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): CompanySizeAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanySizeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["size"] = this.size;
        data["order"] = this.order;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface ICompanySizeAC {
    /** Unique identifier for the company size object */
    id: string;
    /** Size of the company */
    size?: string | undefined;
    /** Order number for sequence */
    order?: number | undefined;
    /** Is option enabled */
    isEnabled: boolean;
}

export class IndustryTypeAC implements IIndustryTypeAC {
    /** Unique identifier for industry group object */
    id!: string;
    /** NAICS code for industry type */
    industryCode?: string | undefined;
    /** Industry type */
    industryType?: string | undefined;
    /** Unique identifier for industry sector object */
    industrySectorId?: string | undefined;

    constructor(data?: IIndustryTypeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.industryCode = _data["industryCode"];
            this.industryType = _data["industryType"];
            this.industrySectorId = _data["industrySectorId"];
        }
    }

    static fromJS(data: any): IndustryTypeAC {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryTypeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["industryCode"] = this.industryCode;
        data["industryType"] = this.industryType;
        data["industrySectorId"] = this.industrySectorId;
        return data; 
    }
}

export interface IIndustryTypeAC {
    /** Unique identifier for industry group object */
    id: string;
    /** NAICS code for industry type */
    industryCode?: string | undefined;
    /** Industry type */
    industryType?: string | undefined;
    /** Unique identifier for industry sector object */
    industrySectorId?: string | undefined;
}

export class IndustryExperienceAC implements IIndustryExperienceAC {
    /** Unique identifier for the industry experience object */
    id!: string;
    /** Industry experience */
    experience?: string | undefined;
    /** Order number for sequence */
    order?: number | undefined;
    /** Is option enabled */
    isEnabled!: boolean;

    constructor(data?: IIndustryExperienceAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.experience = _data["experience"];
            this.order = _data["order"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): IndustryExperienceAC {
        data = typeof data === 'object' ? data : {};
        let result = new IndustryExperienceAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["experience"] = this.experience;
        data["order"] = this.order;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IIndustryExperienceAC {
    /** Unique identifier for the industry experience object */
    id: string;
    /** Industry experience */
    experience?: string | undefined;
    /** Order number for sequence */
    order?: number | undefined;
    /** Is option enabled */
    isEnabled: boolean;
}

export class CompanyFinanceAC implements ICompanyFinanceAC {
    /** Unique identifier for finance object */
    id!: string;
    /** Financial Statement like Income Statement, Balance Sheet */
    financialStatement?: string | undefined;
    /** Name of third party service */
    thirdPartyServiceName?: string | undefined;
    /** List of Financial account details (Periodical list of each standard account and amount) */
    financialAccounts?: PeriodicFinancialAccountsAC[] | undefined;
    /** JSON string financial information */
    financialJson?: string | undefined;
    /** Flag to indicate if background lambda has mapped all finances or not (used during polling) */
    isChartOfAccountMapped!: boolean;
    /** List of mapped Standard account and list of amount (Each account with list of amount) */
    standardAccountList?: StandardAccountsAC[] | undefined;
    /** Updated date time */
    updatedOn?: Date | undefined;
    /** The number by which the amount is divided (default thousands) */
    divisionFactor!: number;
    /** End period till which the finance report is for */
    endPeriod?: string | undefined;
    /** Datetime when finances were retrieved */
    creationDateTime!: Date;
    /** Company selected in third party connected service */
    thirdPartyWiseCompanyName?: string | undefined;
    /** Check if the company has no data for any year in third party connected services */
    isDataEmpty!: boolean;

    constructor(data?: ICompanyFinanceAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.financialStatement = _data["financialStatement"];
            this.thirdPartyServiceName = _data["thirdPartyServiceName"];
            if (Array.isArray(_data["financialAccounts"])) {
                this.financialAccounts = [] as any;
                for (let item of _data["financialAccounts"])
                    this.financialAccounts!.push(PeriodicFinancialAccountsAC.fromJS(item));
            }
            this.financialJson = _data["financialJson"];
            this.isChartOfAccountMapped = _data["isChartOfAccountMapped"];
            if (Array.isArray(_data["standardAccountList"])) {
                this.standardAccountList = [] as any;
                for (let item of _data["standardAccountList"])
                    this.standardAccountList!.push(StandardAccountsAC.fromJS(item));
            }
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
            this.divisionFactor = _data["divisionFactor"];
            this.endPeriod = _data["endPeriod"];
            this.creationDateTime = _data["creationDateTime"] ? new Date(_data["creationDateTime"].toString()) : <any>undefined;
            this.thirdPartyWiseCompanyName = _data["thirdPartyWiseCompanyName"];
            this.isDataEmpty = _data["isDataEmpty"];
        }
    }

    static fromJS(data: any): CompanyFinanceAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyFinanceAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["financialStatement"] = this.financialStatement;
        data["thirdPartyServiceName"] = this.thirdPartyServiceName;
        if (Array.isArray(this.financialAccounts)) {
            data["financialAccounts"] = [];
            for (let item of this.financialAccounts)
                data["financialAccounts"].push(item.toJSON());
        }
        data["financialJson"] = this.financialJson;
        data["isChartOfAccountMapped"] = this.isChartOfAccountMapped;
        if (Array.isArray(this.standardAccountList)) {
            data["standardAccountList"] = [];
            for (let item of this.standardAccountList)
                data["standardAccountList"].push(item.toJSON());
        }
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        data["divisionFactor"] = this.divisionFactor;
        data["endPeriod"] = this.endPeriod;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        data["thirdPartyWiseCompanyName"] = this.thirdPartyWiseCompanyName;
        data["isDataEmpty"] = this.isDataEmpty;
        return data; 
    }
}

export interface ICompanyFinanceAC {
    /** Unique identifier for finance object */
    id: string;
    /** Financial Statement like Income Statement, Balance Sheet */
    financialStatement?: string | undefined;
    /** Name of third party service */
    thirdPartyServiceName?: string | undefined;
    /** List of Financial account details (Periodical list of each standard account and amount) */
    financialAccounts?: PeriodicFinancialAccountsAC[] | undefined;
    /** JSON string financial information */
    financialJson?: string | undefined;
    /** Flag to indicate if background lambda has mapped all finances or not (used during polling) */
    isChartOfAccountMapped: boolean;
    /** List of mapped Standard account and list of amount (Each account with list of amount) */
    standardAccountList?: StandardAccountsAC[] | undefined;
    /** Updated date time */
    updatedOn?: Date | undefined;
    /** The number by which the amount is divided (default thousands) */
    divisionFactor: number;
    /** End period till which the finance report is for */
    endPeriod?: string | undefined;
    /** Datetime when finances were retrieved */
    creationDateTime: Date;
    /** Company selected in third party connected service */
    thirdPartyWiseCompanyName?: string | undefined;
    /** Check if the company has no data for any year in third party connected services */
    isDataEmpty: boolean;
}

export class PeriodicFinancialAccountsAC implements IPeriodicFinancialAccountsAC {
    /** Time period of financial account */
    period?: string | undefined;
    /** List of financial account balance deatails */
    financialAccountBalances?: FinancialAccountBalanceAC[] | undefined;
    /** Name of financial report ex, Income Statement or Balance Sheet etc */
    reportName?: string | undefined;
    /** Flag gets true when xero service is connected */
    isXero!: boolean;

    constructor(data?: IPeriodicFinancialAccountsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.period = _data["period"];
            if (Array.isArray(_data["financialAccountBalances"])) {
                this.financialAccountBalances = [] as any;
                for (let item of _data["financialAccountBalances"])
                    this.financialAccountBalances!.push(FinancialAccountBalanceAC.fromJS(item));
            }
            this.reportName = _data["reportName"];
            this.isXero = _data["isXero"];
        }
    }

    static fromJS(data: any): PeriodicFinancialAccountsAC {
        data = typeof data === 'object' ? data : {};
        let result = new PeriodicFinancialAccountsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["period"] = this.period;
        if (Array.isArray(this.financialAccountBalances)) {
            data["financialAccountBalances"] = [];
            for (let item of this.financialAccountBalances)
                data["financialAccountBalances"].push(item.toJSON());
        }
        data["reportName"] = this.reportName;
        data["isXero"] = this.isXero;
        return data; 
    }
}

export interface IPeriodicFinancialAccountsAC {
    /** Time period of financial account */
    period?: string | undefined;
    /** List of financial account balance deatails */
    financialAccountBalances?: FinancialAccountBalanceAC[] | undefined;
    /** Name of financial report ex, Income Statement or Balance Sheet etc */
    reportName?: string | undefined;
    /** Flag gets true when xero service is connected */
    isXero: boolean;
}

export class FinancialAccountBalanceAC implements IFinancialAccountBalanceAC {
    /** Total Amount */
    amount?: number | undefined;
    /** Name of financial account balance */
    account?: string | undefined;
    /** Period for which the finance account is retrieved */
    period?: string | undefined;
    /** Identifier for financial account */
    id!: number;
    /** Parent Id for financial account */
    parentId?: number | undefined;
    /** Expected/common value for approving loan */
    expectedValue?: number | undefined;
    /** Order of the account */
    order!: number;
    /** List of account and amount mapped from Source */
    source?: AccountChartAC[] | undefined;
    /** Json of Source accounts */
    sourceJson?: string | undefined;

    constructor(data?: IFinancialAccountBalanceAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.account = _data["account"];
            this.period = _data["period"];
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            this.expectedValue = _data["expectedValue"];
            this.order = _data["order"];
            if (Array.isArray(_data["source"])) {
                this.source = [] as any;
                for (let item of _data["source"])
                    this.source!.push(AccountChartAC.fromJS(item));
            }
            this.sourceJson = _data["sourceJson"];
        }
    }

    static fromJS(data: any): FinancialAccountBalanceAC {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialAccountBalanceAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["account"] = this.account;
        data["period"] = this.period;
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        data["expectedValue"] = this.expectedValue;
        data["order"] = this.order;
        if (Array.isArray(this.source)) {
            data["source"] = [];
            for (let item of this.source)
                data["source"].push(item.toJSON());
        }
        data["sourceJson"] = this.sourceJson;
        return data; 
    }
}

export interface IFinancialAccountBalanceAC {
    /** Total Amount */
    amount?: number | undefined;
    /** Name of financial account balance */
    account?: string | undefined;
    /** Period for which the finance account is retrieved */
    period?: string | undefined;
    /** Identifier for financial account */
    id: number;
    /** Parent Id for financial account */
    parentId?: number | undefined;
    /** Expected/common value for approving loan */
    expectedValue?: number | undefined;
    /** Order of the account */
    order: number;
    /** List of account and amount mapped from Source */
    source?: AccountChartAC[] | undefined;
    /** Json of Source accounts */
    sourceJson?: string | undefined;
}

export class AccountChartAC implements IAccountChartAC {
    /** Amount */
    amount!: number;
    /** Account name */
    account?: string | undefined;
    /** Period */
    period?: string | undefined;

    constructor(data?: IAccountChartAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.account = _data["account"];
            this.period = _data["period"];
        }
    }

    static fromJS(data: any): AccountChartAC {
        data = typeof data === 'object' ? data : {};
        let result = new AccountChartAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["account"] = this.account;
        data["period"] = this.period;
        return data; 
    }
}

export interface IAccountChartAC {
    /** Amount */
    amount: number;
    /** Account name */
    account?: string | undefined;
    /** Period */
    period?: string | undefined;
}

export class StandardAccountsAC implements IStandardAccountsAC {
    /** Id of account */
    id!: string;
    /** Standard account name */
    account?: string | undefined;
    /** Amount for account */
    amount?: number[] | undefined;
    /** True if the account is a parent account */
    isParent!: boolean;
    /** Source accounts List */
    sourceList?: AccountChartAC[] | undefined;

    constructor(data?: IStandardAccountsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.account = _data["account"];
            if (Array.isArray(_data["amount"])) {
                this.amount = [] as any;
                for (let item of _data["amount"])
                    this.amount!.push(item);
            }
            this.isParent = _data["isParent"];
            if (Array.isArray(_data["sourceList"])) {
                this.sourceList = [] as any;
                for (let item of _data["sourceList"])
                    this.sourceList!.push(AccountChartAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StandardAccountsAC {
        data = typeof data === 'object' ? data : {};
        let result = new StandardAccountsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["account"] = this.account;
        if (Array.isArray(this.amount)) {
            data["amount"] = [];
            for (let item of this.amount)
                data["amount"].push(item);
        }
        data["isParent"] = this.isParent;
        if (Array.isArray(this.sourceList)) {
            data["sourceList"] = [];
            for (let item of this.sourceList)
                data["sourceList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStandardAccountsAC {
    /** Id of account */
    id: string;
    /** Standard account name */
    account?: string | undefined;
    /** Amount for account */
    amount?: number[] | undefined;
    /** True if the account is a parent account */
    isParent: boolean;
    /** Source accounts List */
    sourceList?: AccountChartAC[] | undefined;
}

export class PersonalFinanceAC implements IPersonalFinanceAC {
    /** Unique identifier for personal finance object */
    id?: string | undefined;
    /** Financial Statement name (i.e. Personal Finance) */
    financialStatement?: string | undefined;
    /** Summary of financial information */
    summary?: PersonalFinanceSummaryAC | undefined;
    /** Account wise list of financial details  */
    accounts?: PersonalFinanceAccountAC[] | undefined;

    constructor(data?: IPersonalFinanceAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.financialStatement = _data["financialStatement"];
            this.summary = _data["summary"] ? PersonalFinanceSummaryAC.fromJS(_data["summary"]) : <any>undefined;
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(PersonalFinanceAccountAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["financialStatement"] = this.financialStatement;
        data["summary"] = this.summary ? this.summary.toJSON() : <any>undefined;
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceAC {
    /** Unique identifier for personal finance object */
    id?: string | undefined;
    /** Financial Statement name (i.e. Personal Finance) */
    financialStatement?: string | undefined;
    /** Summary of financial information */
    summary?: PersonalFinanceSummaryAC | undefined;
    /** Account wise list of financial details  */
    accounts?: PersonalFinanceAccountAC[] | undefined;
}

export class PersonalFinanceSummaryAC implements IPersonalFinanceSummaryAC {
    /** List of accounts containing categories' details */
    accounts?: PersonalFinanceAccountSummaryAC[] | undefined;

    constructor(data?: IPersonalFinanceSummaryAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["accounts"])) {
                this.accounts = [] as any;
                for (let item of _data["accounts"])
                    this.accounts!.push(PersonalFinanceAccountSummaryAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceSummaryAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceSummaryAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.accounts)) {
            data["accounts"] = [];
            for (let item of this.accounts)
                data["accounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceSummaryAC {
    /** List of accounts containing categories' details */
    accounts?: PersonalFinanceAccountSummaryAC[] | undefined;
}

export class PersonalFinanceAccountSummaryAC implements IPersonalFinanceAccountSummaryAC {
    /** Account name */
    name?: string | undefined;
    /** Account order */
    order!: number;
    /** List of categories linked with account */
    categories?: PersonalFinanceCategorySummaryAC[] | undefined;

    constructor(data?: IPersonalFinanceAccountSummaryAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(PersonalFinanceCategorySummaryAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceAccountSummaryAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceAccountSummaryAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceAccountSummaryAC {
    /** Account name */
    name?: string | undefined;
    /** Account order */
    order: number;
    /** List of categories linked with account */
    categories?: PersonalFinanceCategorySummaryAC[] | undefined;
}

export class PersonalFinanceCategorySummaryAC implements IPersonalFinanceCategorySummaryAC {
    /** Category name */
    name?: string | undefined;
    /** Category order */
    order!: number;
    /** Original amount of category */
    originalAmount?: number | undefined;
    /** Current amount of category */
    currentAmount?: number | undefined;

    constructor(data?: IPersonalFinanceCategorySummaryAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.order = _data["order"];
            this.originalAmount = _data["originalAmount"];
            this.currentAmount = _data["currentAmount"];
        }
    }

    static fromJS(data: any): PersonalFinanceCategorySummaryAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceCategorySummaryAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["order"] = this.order;
        data["originalAmount"] = this.originalAmount;
        data["currentAmount"] = this.currentAmount;
        return data; 
    }
}

export interface IPersonalFinanceCategorySummaryAC {
    /** Category name */
    name?: string | undefined;
    /** Category order */
    order: number;
    /** Original amount of category */
    originalAmount?: number | undefined;
    /** Current amount of category */
    currentAmount?: number | undefined;
}

export class PersonalFinanceAccountAC implements IPersonalFinanceAccountAC {
    /** Unique identifier for accpunt object */
    id!: string;
    /** Account name */
    name?: string | undefined;
    /** Account order */
    order!: number;
    /** List of categories linked with account */
    categories?: PersonalFinanceCategoryAC[] | undefined;

    constructor(data?: IPersonalFinanceAccountAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            if (Array.isArray(_data["categories"])) {
                this.categories = [] as any;
                for (let item of _data["categories"])
                    this.categories!.push(PersonalFinanceCategoryAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceAccountAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceAccountAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        if (Array.isArray(this.categories)) {
            data["categories"] = [];
            for (let item of this.categories)
                data["categories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceAccountAC {
    /** Unique identifier for accpunt object */
    id: string;
    /** Account name */
    name?: string | undefined;
    /** Account order */
    order: number;
    /** List of categories linked with account */
    categories?: PersonalFinanceCategoryAC[] | undefined;
}

export class PersonalFinanceCategoryAC implements IPersonalFinanceCategoryAC {
    /** Unique identifier for category object */
    id!: string;
    /** Category name */
    name?: string | undefined;
    /** Category order */
    order!: number;
    /** Parent attribute (of parent category) object  */
    parentAttribute?: PersonalFinanceAttributeAC | undefined;
    /** List of attributes mapped with category */
    attributes?: PersonalFinanceAttributeAC[] | undefined;
    /** List of child categories */
    childCategories?: PersonalFinanceCategoryAC[] | undefined;

    constructor(data?: IPersonalFinanceCategoryAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.parentAttribute = _data["parentAttribute"] ? PersonalFinanceAttributeAC.fromJS(_data["parentAttribute"]) : <any>undefined;
            if (Array.isArray(_data["attributes"])) {
                this.attributes = [] as any;
                for (let item of _data["attributes"])
                    this.attributes!.push(PersonalFinanceAttributeAC.fromJS(item));
            }
            if (Array.isArray(_data["childCategories"])) {
                this.childCategories = [] as any;
                for (let item of _data["childCategories"])
                    this.childCategories!.push(PersonalFinanceCategoryAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceCategoryAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceCategoryAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["parentAttribute"] = this.parentAttribute ? this.parentAttribute.toJSON() : <any>undefined;
        if (Array.isArray(this.attributes)) {
            data["attributes"] = [];
            for (let item of this.attributes)
                data["attributes"].push(item.toJSON());
        }
        if (Array.isArray(this.childCategories)) {
            data["childCategories"] = [];
            for (let item of this.childCategories)
                data["childCategories"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceCategoryAC {
    /** Unique identifier for category object */
    id: string;
    /** Category name */
    name?: string | undefined;
    /** Category order */
    order: number;
    /** Parent attribute (of parent category) object  */
    parentAttribute?: PersonalFinanceAttributeAC | undefined;
    /** List of attributes mapped with category */
    attributes?: PersonalFinanceAttributeAC[] | undefined;
    /** List of child categories */
    childCategories?: PersonalFinanceCategoryAC[] | undefined;
}

export class PersonalFinanceAttributeAC implements IPersonalFinanceAttributeAC {
    /** Unique identifier for attribute object */
    id!: string;
    /** Attribute (question) text */
    text?: string | undefined;
    /** Attribute order */
    order!: number;
    /** Attribute's response (answer) */
    answer?: string | undefined;
    /** Boolean type attribute's response (answer) (Used in UI, don't remove it) */
    booleanAnswer?: boolean | undefined;
    /** Constant (dropdown menu) linked with attribute */
    constant?: PersonalFinanceConstantAC | undefined;
    /** Attribute response type */
    fieldType!: PersonalFinanceAttributeFieldType;
    /** List of attribute's ordered child attributes */
    childAttributeSets?: PersonalFinanceOrderedAttributeAC[] | undefined;
    /** Address type attribute's response (answer) (don't remove it, used in UI) */
    address?: AddressAC | undefined;

    constructor(data?: IPersonalFinanceAttributeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.text = _data["text"];
            this.order = _data["order"];
            this.answer = _data["answer"];
            this.booleanAnswer = _data["booleanAnswer"];
            this.constant = _data["constant"] ? PersonalFinanceConstantAC.fromJS(_data["constant"]) : <any>undefined;
            this.fieldType = _data["fieldType"];
            if (Array.isArray(_data["childAttributeSets"])) {
                this.childAttributeSets = [] as any;
                for (let item of _data["childAttributeSets"])
                    this.childAttributeSets!.push(PersonalFinanceOrderedAttributeAC.fromJS(item));
            }
            this.address = _data["address"] ? AddressAC.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): PersonalFinanceAttributeAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceAttributeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["text"] = this.text;
        data["order"] = this.order;
        data["answer"] = this.answer;
        data["booleanAnswer"] = this.booleanAnswer;
        data["constant"] = this.constant ? this.constant.toJSON() : <any>undefined;
        data["fieldType"] = this.fieldType;
        if (Array.isArray(this.childAttributeSets)) {
            data["childAttributeSets"] = [];
            for (let item of this.childAttributeSets)
                data["childAttributeSets"].push(item.toJSON());
        }
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IPersonalFinanceAttributeAC {
    /** Unique identifier for attribute object */
    id: string;
    /** Attribute (question) text */
    text?: string | undefined;
    /** Attribute order */
    order: number;
    /** Attribute's response (answer) */
    answer?: string | undefined;
    /** Boolean type attribute's response (answer) (Used in UI, don't remove it) */
    booleanAnswer?: boolean | undefined;
    /** Constant (dropdown menu) linked with attribute */
    constant?: PersonalFinanceConstantAC | undefined;
    /** Attribute response type */
    fieldType: PersonalFinanceAttributeFieldType;
    /** List of attribute's ordered child attributes */
    childAttributeSets?: PersonalFinanceOrderedAttributeAC[] | undefined;
    /** Address type attribute's response (answer) (don't remove it, used in UI) */
    address?: AddressAC | undefined;
}

export class PersonalFinanceConstantAC implements IPersonalFinanceConstantAC {
    /** Unique identifier of constant object */
    id!: string;
    /** Constant name */
    name?: string | undefined;
    /** List of options available for constant (dropdown) */
    options?: PersonalFinanceConstantOptionAC[] | undefined;

    constructor(data?: IPersonalFinanceConstantAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(PersonalFinanceConstantOptionAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceConstantAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceConstantAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceConstantAC {
    /** Unique identifier of constant object */
    id: string;
    /** Constant name */
    name?: string | undefined;
    /** List of options available for constant (dropdown) */
    options?: PersonalFinanceConstantOptionAC[] | undefined;
}

export class PersonalFinanceConstantOptionAC implements IPersonalFinanceConstantOptionAC {
    /** Unique identifier for option (of dropdown) object */
    id!: number;
    /** Option value */
    value?: string | undefined;
    /** Option order */
    order!: number;

    constructor(data?: IPersonalFinanceConstantOptionAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): PersonalFinanceConstantOptionAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceConstantOptionAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["order"] = this.order;
        return data; 
    }
}

export interface IPersonalFinanceConstantOptionAC {
    /** Unique identifier for option (of dropdown) object */
    id: number;
    /** Option value */
    value?: string | undefined;
    /** Option order */
    order: number;
}

export enum PersonalFinanceAttributeFieldType {
    Number = 0,
    Boolean = 1,
    Text = 2,
    Dropdown = 3,
    Address = 4,
    Date = 5,
    Currency = 6,
    BankAccountNumber = 7,
    SingleCheckbox = 8,
}

export class PersonalFinanceOrderedAttributeAC implements IPersonalFinanceOrderedAttributeAC {
    /** Attributes' set order */
    order!: number;
    /** List of child attributes */
    childAttributes?: PersonalFinanceAttributeAC[] | undefined;

    constructor(data?: IPersonalFinanceOrderedAttributeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.order = _data["order"];
            if (Array.isArray(_data["childAttributes"])) {
                this.childAttributes = [] as any;
                for (let item of _data["childAttributes"])
                    this.childAttributes!.push(PersonalFinanceAttributeAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PersonalFinanceOrderedAttributeAC {
        data = typeof data === 'object' ? data : {};
        let result = new PersonalFinanceOrderedAttributeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["order"] = this.order;
        if (Array.isArray(this.childAttributes)) {
            data["childAttributes"] = [];
            for (let item of this.childAttributes)
                data["childAttributes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IPersonalFinanceOrderedAttributeAC {
    /** Attributes' set order */
    order: number;
    /** List of child attributes */
    childAttributes?: PersonalFinanceAttributeAC[] | undefined;
}

export class CreditReportAC implements ICreditReportAC {
    /** Unique identifier for credit report object */
    id!: string;
    /** JSON string of credit report */
    creditReportJson?: string | undefined;
    /** Unique identifier for integarted service configuration */
    integratedServiceConfigurationId!: string;
    /** Integarted service configuration name */
    integratedServiceConfigurationName?: string | undefined;

    constructor(data?: ICreditReportAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.creditReportJson = _data["creditReportJson"];
            this.integratedServiceConfigurationId = _data["integratedServiceConfigurationId"];
            this.integratedServiceConfigurationName = _data["integratedServiceConfigurationName"];
        }
    }

    static fromJS(data: any): CreditReportAC {
        data = typeof data === 'object' ? data : {};
        let result = new CreditReportAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["creditReportJson"] = this.creditReportJson;
        data["integratedServiceConfigurationId"] = this.integratedServiceConfigurationId;
        data["integratedServiceConfigurationName"] = this.integratedServiceConfigurationName;
        return data; 
    }
}

export interface ICreditReportAC {
    /** Unique identifier for credit report object */
    id: string;
    /** JSON string of credit report */
    creditReportJson?: string | undefined;
    /** Unique identifier for integarted service configuration */
    integratedServiceConfigurationId: string;
    /** Integarted service configuration name */
    integratedServiceConfigurationName?: string | undefined;
}

export class ConsentAC implements IConsentAC {
    /** Unique identifier for user object */
    userId!: string;
    /** Unique identifier for consent statement */
    consentId?: string | undefined;
    /** Consent statement */
    consentText?: string | undefined;
    /** Is consent given? */
    isConsentGiven!: boolean;

    constructor(data?: IConsentAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.consentId = _data["consentId"];
            this.consentText = _data["consentText"];
            this.isConsentGiven = _data["isConsentGiven"];
        }
    }

    static fromJS(data: any): ConsentAC {
        data = typeof data === 'object' ? data : {};
        let result = new ConsentAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["consentId"] = this.consentId;
        data["consentText"] = this.consentText;
        data["isConsentGiven"] = this.isConsentGiven;
        return data; 
    }
}

export interface IConsentAC {
    /** Unique identifier for user object */
    userId: string;
    /** Unique identifier for consent statement */
    consentId?: string | undefined;
    /** Consent statement */
    consentText?: string | undefined;
    /** Is consent given? */
    isConsentGiven: boolean;
}

export class TaxAC implements ITaxAC {
    /** Unique identifier for the entity tax form object */
    id!: string;
    /** Entity tax yearly mapping details */
    entityTaxAccount?: EntityTaxAccountAC | undefined;
    /** Datetime when taxes file was save */
    creationDateTime!: Date;

    constructor(data?: ITaxAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityTaxAccount = _data["entityTaxAccount"] ? EntityTaxAccountAC.fromJS(_data["entityTaxAccount"]) : <any>undefined;
            this.creationDateTime = _data["creationDateTime"] ? new Date(_data["creationDateTime"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TaxAC {
        data = typeof data === 'object' ? data : {};
        let result = new TaxAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityTaxAccount"] = this.entityTaxAccount ? this.entityTaxAccount.toJSON() : <any>undefined;
        data["creationDateTime"] = this.creationDateTime ? this.creationDateTime.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITaxAC {
    /** Unique identifier for the entity tax form object */
    id: string;
    /** Entity tax yearly mapping details */
    entityTaxAccount?: EntityTaxAccountAC | undefined;
    /** Datetime when taxes file was save */
    creationDateTime: Date;
}

export class EntityTaxAccountAC implements IEntityTaxAccountAC {
    /** Unique identifier for the entity tax yearly mapping object */
    id!: string;
    /** Time period of tax account */
    period?: string | undefined;
    /** Document details */
    document?: DocumentAC | undefined;

    constructor(data?: IEntityTaxAccountAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.period = _data["period"];
            this.document = _data["document"] ? DocumentAC.fromJS(_data["document"]) : <any>undefined;
        }
    }

    static fromJS(data: any): EntityTaxAccountAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityTaxAccountAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["period"] = this.period;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IEntityTaxAccountAC {
    /** Unique identifier for the entity tax yearly mapping object */
    id: string;
    /** Time period of tax account */
    period?: string | undefined;
    /** Document details */
    document?: DocumentAC | undefined;
}

export class DocumentAC implements IDocumentAC {
    /** Unique identifier for document object */
    id?: string | undefined;
    /** Name of the document */
    name?: string | undefined;
    /** Path of the upload document */
    path?: string | undefined;
    /** Path for the download document */
    downloadPath?: string | undefined;

    constructor(data?: IDocumentAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.path = _data["path"];
            this.downloadPath = _data["downloadPath"];
        }
    }

    static fromJS(data: any): DocumentAC {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["path"] = this.path;
        data["downloadPath"] = this.downloadPath;
        return data; 
    }
}

export interface IDocumentAC {
    /** Unique identifier for document object */
    id?: string | undefined;
    /** Name of the document */
    name?: string | undefined;
    /** Path of the upload document */
    path?: string | undefined;
    /** Path for the download document */
    downloadPath?: string | undefined;
}

export class AdditionalDocumentAC implements IAdditionalDocumentAC {
    /** Unique identifier for AdditionalDocumentAC object */
    id!: string;
    /** Document type's details */
    documentType?: AdditionalDocumentTypeAC | undefined;
    /** Document's details */
    document?: DocumentAC | undefined;

    constructor(data?: IAdditionalDocumentAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentType = _data["documentType"] ? AdditionalDocumentTypeAC.fromJS(_data["documentType"]) : <any>undefined;
            this.document = _data["document"] ? DocumentAC.fromJS(_data["document"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AdditionalDocumentAC {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalDocumentAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentType"] = this.documentType ? this.documentType.toJSON() : <any>undefined;
        data["document"] = this.document ? this.document.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAdditionalDocumentAC {
    /** Unique identifier for AdditionalDocumentAC object */
    id: string;
    /** Document type's details */
    documentType?: AdditionalDocumentTypeAC | undefined;
    /** Document's details */
    document?: DocumentAC | undefined;
}

export class AdditionalDocumentTypeAC implements IAdditionalDocumentTypeAC {
    /** Unique identifier for AdditionalDocumentTypeAC object */
    id!: string;
    /** Type of document */
    type?: string | undefined;
    /** Resource, the document type is related with */
    documentTypeFor!: ResourceType;

    constructor(data?: IAdditionalDocumentTypeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.documentTypeFor = _data["documentTypeFor"];
        }
    }

    static fromJS(data: any): AdditionalDocumentTypeAC {
        data = typeof data === 'object' ? data : {};
        let result = new AdditionalDocumentTypeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["documentTypeFor"] = this.documentTypeFor;
        return data; 
    }
}

export interface IAdditionalDocumentTypeAC {
    /** Unique identifier for AdditionalDocumentTypeAC object */
    id: string;
    /** Type of document */
    type?: string | undefined;
    /** Resource, the document type is related with */
    documentTypeFor: ResourceType;
}

export enum ResourceType {
    Other = 0,
    Company = 1,
    Loan = 2,
    User = 3,
}

export class EntityRelationMappingAC implements IEntityRelationMappingAC {
    /** Unique identifier for the entity relationship mapping object. */
    id?: string | undefined;
    /** Relationship object */
    relation?: RelationshipAC | undefined;
    /** Share percentage */
    sharePercentage?: number | undefined;
    /** Unique identifier for primary entity object(borrowing entity) */
    primaryEntityId!: string;

    constructor(data?: IEntityRelationMappingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.relation = _data["relation"] ? RelationshipAC.fromJS(_data["relation"]) : <any>undefined;
            this.sharePercentage = _data["sharePercentage"];
            this.primaryEntityId = _data["primaryEntityId"];
        }
    }

    static fromJS(data: any): EntityRelationMappingAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityRelationMappingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["relation"] = this.relation ? this.relation.toJSON() : <any>undefined;
        data["sharePercentage"] = this.sharePercentage;
        data["primaryEntityId"] = this.primaryEntityId;
        return data; 
    }
}

export interface IEntityRelationMappingAC {
    /** Unique identifier for the entity relationship mapping object. */
    id?: string | undefined;
    /** Relationship object */
    relation?: RelationshipAC | undefined;
    /** Share percentage */
    sharePercentage?: number | undefined;
    /** Unique identifier for primary entity object(borrowing entity) */
    primaryEntityId: string;
}

export class RelationshipAC implements IRelationshipAC {
    id!: string;
    name?: string | undefined;

    constructor(data?: IRelationshipAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): RelationshipAC {
        data = typeof data === 'object' ? data : {};
        let result = new RelationshipAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface IRelationshipAC {
    id: string;
    name?: string | undefined;
}

export class RecommendedProductAC implements IRecommendedProductAC {
    /** Unique identifier for recommended product. */
    id!: string;
    /** Name of the recommended product. */
    name!: string;
    /** Description of the recommended product. */
    description!: string;
    /** Start date of the recommended product. */
    productStartDate!: Date;
    /** End date of the recommended product. */
    productEndDate!: Date;
    /** Percentage of product suitable for your business */
    businessPercentageSuitability?: number | undefined;
    /** Product recommended checked */
    isProductRecommended!: boolean;
    /** The loan product's detail. */
    productDetails?: ProductDetailsAC | undefined;
    /** Product amount range */
    productAmountRange?: string | undefined;
    /** Product period range */
    productPeriodRange?: string | undefined;
    /** Is previous product matched with current product. */
    isPreviousProductMatched?: boolean | undefined;
    /** List of description points for product. */
    descriptionPoints?: DescriptionPointSeedAC[] | undefined;

    constructor(data?: IRecommendedProductAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.productStartDate = _data["productStartDate"] ? new Date(_data["productStartDate"].toString()) : <any>undefined;
            this.productEndDate = _data["productEndDate"] ? new Date(_data["productEndDate"].toString()) : <any>undefined;
            this.businessPercentageSuitability = _data["businessPercentageSuitability"];
            this.isProductRecommended = _data["isProductRecommended"];
            this.productDetails = _data["productDetails"] ? ProductDetailsAC.fromJS(_data["productDetails"]) : <any>undefined;
            this.productAmountRange = _data["productAmountRange"];
            this.productPeriodRange = _data["productPeriodRange"];
            this.isPreviousProductMatched = _data["isPreviousProductMatched"];
            if (Array.isArray(_data["descriptionPoints"])) {
                this.descriptionPoints = [] as any;
                for (let item of _data["descriptionPoints"])
                    this.descriptionPoints!.push(DescriptionPointSeedAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecommendedProductAC {
        data = typeof data === 'object' ? data : {};
        let result = new RecommendedProductAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["productStartDate"] = this.productStartDate ? this.productStartDate.toISOString() : <any>undefined;
        data["productEndDate"] = this.productEndDate ? this.productEndDate.toISOString() : <any>undefined;
        data["businessPercentageSuitability"] = this.businessPercentageSuitability;
        data["isProductRecommended"] = this.isProductRecommended;
        data["productDetails"] = this.productDetails ? this.productDetails.toJSON() : <any>undefined;
        data["productAmountRange"] = this.productAmountRange;
        data["productPeriodRange"] = this.productPeriodRange;
        data["isPreviousProductMatched"] = this.isPreviousProductMatched;
        if (Array.isArray(this.descriptionPoints)) {
            data["descriptionPoints"] = [];
            for (let item of this.descriptionPoints)
                data["descriptionPoints"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRecommendedProductAC {
    /** Unique identifier for recommended product. */
    id: string;
    /** Name of the recommended product. */
    name: string;
    /** Description of the recommended product. */
    description: string;
    /** Start date of the recommended product. */
    productStartDate: Date;
    /** End date of the recommended product. */
    productEndDate: Date;
    /** Percentage of product suitable for your business */
    businessPercentageSuitability?: number | undefined;
    /** Product recommended checked */
    isProductRecommended: boolean;
    /** The loan product's detail. */
    productDetails?: ProductDetailsAC | undefined;
    /** Product amount range */
    productAmountRange?: string | undefined;
    /** Product period range */
    productPeriodRange?: string | undefined;
    /** Is previous product matched with current product. */
    isPreviousProductMatched?: boolean | undefined;
    /** List of description points for product. */
    descriptionPoints?: DescriptionPointSeedAC[] | undefined;
}

export class ProductDetailsAC implements IProductDetailsAC {
    /** Interest rate based on self declared credit score of loan initiator */
    interestRate!: number;
    /** Minimum product tenure  */
    minProductTenure!: number;
    /** Maximum product tenure */
    maxProductTenure!: number;
    /** Tenure stepper count */
    tenureStepperCount!: number;
    /** Laon amount  */
    amount!: number;
    /** Loan Period. */
    period!: number;
    /** Minimum product amount */
    minProductAmount!: number;
    /** Maximum product amount */
    maxProductAmount!: number;
    /** Amount stepper count */
    amountStepperCount!: number;
    /** Monthly payment amount */
    monthlyPayment!: number;
    /** Minimum monthly payment amount */
    minMonthlyPayment!: number;
    /** Maximum monthly payment amount */
    maxMonthlyPayment!: number;
    /** Total payment amount */
    totalPayment?: string | undefined;
    /** Total interest percentage */
    totalInterest?: string | undefined;

    constructor(data?: IProductDetailsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interestRate = _data["interestRate"];
            this.minProductTenure = _data["minProductTenure"];
            this.maxProductTenure = _data["maxProductTenure"];
            this.tenureStepperCount = _data["tenureStepperCount"];
            this.amount = _data["amount"];
            this.period = _data["period"];
            this.minProductAmount = _data["minProductAmount"];
            this.maxProductAmount = _data["maxProductAmount"];
            this.amountStepperCount = _data["amountStepperCount"];
            this.monthlyPayment = _data["monthlyPayment"];
            this.minMonthlyPayment = _data["minMonthlyPayment"];
            this.maxMonthlyPayment = _data["maxMonthlyPayment"];
            this.totalPayment = _data["totalPayment"];
            this.totalInterest = _data["totalInterest"];
        }
    }

    static fromJS(data: any): ProductDetailsAC {
        data = typeof data === 'object' ? data : {};
        let result = new ProductDetailsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interestRate"] = this.interestRate;
        data["minProductTenure"] = this.minProductTenure;
        data["maxProductTenure"] = this.maxProductTenure;
        data["tenureStepperCount"] = this.tenureStepperCount;
        data["amount"] = this.amount;
        data["period"] = this.period;
        data["minProductAmount"] = this.minProductAmount;
        data["maxProductAmount"] = this.maxProductAmount;
        data["amountStepperCount"] = this.amountStepperCount;
        data["monthlyPayment"] = this.monthlyPayment;
        data["minMonthlyPayment"] = this.minMonthlyPayment;
        data["maxMonthlyPayment"] = this.maxMonthlyPayment;
        data["totalPayment"] = this.totalPayment;
        data["totalInterest"] = this.totalInterest;
        return data; 
    }
}

export interface IProductDetailsAC {
    /** Interest rate based on self declared credit score of loan initiator */
    interestRate: number;
    /** Minimum product tenure  */
    minProductTenure: number;
    /** Maximum product tenure */
    maxProductTenure: number;
    /** Tenure stepper count */
    tenureStepperCount: number;
    /** Laon amount  */
    amount: number;
    /** Loan Period. */
    period: number;
    /** Minimum product amount */
    minProductAmount: number;
    /** Maximum product amount */
    maxProductAmount: number;
    /** Amount stepper count */
    amountStepperCount: number;
    /** Monthly payment amount */
    monthlyPayment: number;
    /** Minimum monthly payment amount */
    minMonthlyPayment: number;
    /** Maximum monthly payment amount */
    maxMonthlyPayment: number;
    /** Total payment amount */
    totalPayment?: string | undefined;
    /** Total interest percentage */
    totalInterest?: string | undefined;
}

export class DescriptionPointSeedAC implements IDescriptionPointSeedAC {
    text?: string | undefined;
    order!: number;

    constructor(data?: IDescriptionPointSeedAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.text = _data["text"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): DescriptionPointSeedAC {
        data = typeof data === 'object' ? data : {};
        let result = new DescriptionPointSeedAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["text"] = this.text;
        data["order"] = this.order;
        return data; 
    }
}

export interface IDescriptionPointSeedAC {
    text?: string | undefined;
    order: number;
}

export class FilterAC implements IFilterAC {
    /** Specific field */
    field?: string | undefined;
    /** Value of specific field */
    value?: string | undefined;
    /** Operation for the field */
    operator?: string | undefined;

    constructor(data?: IFilterAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.field = _data["field"];
            this.value = _data["value"];
            this.operator = _data["operator"];
        }
    }

    static fromJS(data: any): FilterAC {
        data = typeof data === 'object' ? data : {};
        let result = new FilterAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["field"] = this.field;
        data["value"] = this.value;
        data["operator"] = this.operator;
        return data; 
    }
}

export interface IFilterAC {
    /** Specific field */
    field?: string | undefined;
    /** Value of specific field */
    value?: string | undefined;
    /** Operation for the field */
    operator?: string | undefined;
}

export class TaxFormValueLabelMappingAC implements ITaxFormValueLabelMappingAC {
    /** Unique Identifier */
    id!: string;
    /** Extracted value from PDF */
    value?: string | undefined;
    /** Corrected value by banker */
    correctedValue?: string | undefined;
    /** Label for the given value */
    label?: string | undefined;
    /** Confidence of extracted value (Range in between 0-1 value)  */
    confidence!: number;
    /** Unique identifier of EntityTaxYearlyMapping object */
    entityTaxYearlyMappingId!: string;

    constructor(data?: ITaxFormValueLabelMappingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
            this.correctedValue = _data["correctedValue"];
            this.label = _data["label"];
            this.confidence = _data["confidence"];
            this.entityTaxYearlyMappingId = _data["entityTaxYearlyMappingId"];
        }
    }

    static fromJS(data: any): TaxFormValueLabelMappingAC {
        data = typeof data === 'object' ? data : {};
        let result = new TaxFormValueLabelMappingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        data["correctedValue"] = this.correctedValue;
        data["label"] = this.label;
        data["confidence"] = this.confidence;
        data["entityTaxYearlyMappingId"] = this.entityTaxYearlyMappingId;
        return data; 
    }
}

export interface ITaxFormValueLabelMappingAC {
    /** Unique Identifier */
    id: string;
    /** Extracted value from PDF */
    value?: string | undefined;
    /** Corrected value by banker */
    correctedValue?: string | undefined;
    /** Label for the given value */
    label?: string | undefined;
    /** Confidence of extracted value (Range in between 0-1 value)  */
    confidence: number;
    /** Unique identifier of EntityTaxYearlyMapping object */
    entityTaxYearlyMappingId: string;
}

export class AuditDateWiseLogsAC implements IAuditDateWiseLogsAC {
    /** Created date of the log. */
    createdOn!: Date;
    /** Contains list of audit logs by date. */
    auditLogs?: AuditLogAC[] | undefined;

    constructor(data?: IAuditDateWiseLogsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            if (Array.isArray(_data["auditLogs"])) {
                this.auditLogs = [] as any;
                for (let item of _data["auditLogs"])
                    this.auditLogs!.push(AuditLogAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): AuditDateWiseLogsAC {
        data = typeof data === 'object' ? data : {};
        let result = new AuditDateWiseLogsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        if (Array.isArray(this.auditLogs)) {
            data["auditLogs"] = [];
            for (let item of this.auditLogs)
                data["auditLogs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAuditDateWiseLogsAC {
    /** Created date of the log. */
    createdOn: Date;
    /** Contains list of audit logs by date. */
    auditLogs?: AuditLogAC[] | undefined;
}

export class AuditLogAC implements IAuditLogAC {
    /** Unique audit LogId. */
    id!: string;
    /** Table name that operation perform on the table. */
    tableName?: string | undefined;
    /** Action like "Insert", "Update" or "Delete" */
    action?: string | undefined;
    /** Json object for the table details. */
    auditJson?: string | undefined;
    /** List of fields of the table. It contains old value and new value of the field. */
    auditLogFields?: AuditLogFieldAC[] | undefined;
    /** Created date of the log. */
    createdOn!: Date;
    /** If it's true when log generated by the bank user else false. */
    isBankUser!: boolean;
    /** UserId of the who generates the log. */
    createdByUserId?: string | undefined;
    /** User name of the generated log. */
    userName?: string | undefined;
    /** User email of the generated log. */
    email?: string | undefined;
    /** Primary key of the audit log table. */
    tablePk!: string;
    /** Ip address of the user. */
    ipAddress?: string | undefined;
    /** It uses to fetch the block wise record.
eg. Company and loan application. */
    logBlockName!: ResourceType;
    /** LoanId or EntityId. It's use to fetch the block wise log details of the loan or entity. */
    logBlockNameId?: string | undefined;
    /** It's used to show old value in the dialogue. */
    isShowOldValue!: boolean;

    constructor(data?: IAuditLogAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.tableName = _data["tableName"];
            this.action = _data["action"];
            this.auditJson = _data["auditJson"];
            if (Array.isArray(_data["auditLogFields"])) {
                this.auditLogFields = [] as any;
                for (let item of _data["auditLogFields"])
                    this.auditLogFields!.push(AuditLogFieldAC.fromJS(item));
            }
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.isBankUser = _data["isBankUser"];
            this.createdByUserId = _data["createdByUserId"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.tablePk = _data["tablePk"];
            this.ipAddress = _data["ipAddress"];
            this.logBlockName = _data["logBlockName"];
            this.logBlockNameId = _data["logBlockNameId"];
            this.isShowOldValue = _data["isShowOldValue"];
        }
    }

    static fromJS(data: any): AuditLogAC {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["tableName"] = this.tableName;
        data["action"] = this.action;
        data["auditJson"] = this.auditJson;
        if (Array.isArray(this.auditLogFields)) {
            data["auditLogFields"] = [];
            for (let item of this.auditLogFields)
                data["auditLogFields"].push(item.toJSON());
        }
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["isBankUser"] = this.isBankUser;
        data["createdByUserId"] = this.createdByUserId;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["tablePk"] = this.tablePk;
        data["ipAddress"] = this.ipAddress;
        data["logBlockName"] = this.logBlockName;
        data["logBlockNameId"] = this.logBlockNameId;
        data["isShowOldValue"] = this.isShowOldValue;
        return data; 
    }
}

export interface IAuditLogAC {
    /** Unique audit LogId. */
    id: string;
    /** Table name that operation perform on the table. */
    tableName?: string | undefined;
    /** Action like "Insert", "Update" or "Delete" */
    action?: string | undefined;
    /** Json object for the table details. */
    auditJson?: string | undefined;
    /** List of fields of the table. It contains old value and new value of the field. */
    auditLogFields?: AuditLogFieldAC[] | undefined;
    /** Created date of the log. */
    createdOn: Date;
    /** If it's true when log generated by the bank user else false. */
    isBankUser: boolean;
    /** UserId of the who generates the log. */
    createdByUserId?: string | undefined;
    /** User name of the generated log. */
    userName?: string | undefined;
    /** User email of the generated log. */
    email?: string | undefined;
    /** Primary key of the audit log table. */
    tablePk: string;
    /** Ip address of the user. */
    ipAddress?: string | undefined;
    /** It uses to fetch the block wise record.
eg. Company and loan application. */
    logBlockName: ResourceType;
    /** LoanId or EntityId. It's use to fetch the block wise log details of the loan or entity. */
    logBlockNameId?: string | undefined;
    /** It's used to show old value in the dialogue. */
    isShowOldValue: boolean;
}

export class AuditLogFieldAC implements IAuditLogFieldAC {
    /** Field name. */
    columnName?: string | undefined;
    /** Old value of the field. */
    originalValue?: any | undefined;
    /** New value of the field. */
    newValue?: any | undefined;
    /** Field type is guid. */
    isGuid!: boolean;
    /** Log created date to show accurate data in the popup. */
    logDate!: Date;
    /** List of audit log ids. */
    ids?: any[] | undefined;

    constructor(data?: IAuditLogFieldAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.columnName = _data["columnName"];
            this.originalValue = _data["originalValue"];
            this.newValue = _data["newValue"];
            this.isGuid = _data["isGuid"];
            this.logDate = _data["logDate"] ? new Date(_data["logDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["ids"])) {
                this.ids = [] as any;
                for (let item of _data["ids"])
                    this.ids!.push(item);
            }
        }
    }

    static fromJS(data: any): AuditLogFieldAC {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogFieldAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["columnName"] = this.columnName;
        data["originalValue"] = this.originalValue;
        data["newValue"] = this.newValue;
        data["isGuid"] = this.isGuid;
        data["logDate"] = this.logDate ? this.logDate.toISOString() : <any>undefined;
        if (Array.isArray(this.ids)) {
            data["ids"] = [];
            for (let item of this.ids)
                data["ids"].push(item);
        }
        return data; 
    }
}

export interface IAuditLogFieldAC {
    /** Field name. */
    columnName?: string | undefined;
    /** Old value of the field. */
    originalValue?: any | undefined;
    /** New value of the field. */
    newValue?: any | undefined;
    /** Field type is guid. */
    isGuid: boolean;
    /** Log created date to show accurate data in the popup. */
    logDate: Date;
    /** List of audit log ids. */
    ids?: any[] | undefined;
}

export class ThirdPartyServiceCallbackDataAC implements IThirdPartyServiceCallbackDataAC {
    thirdPartyServiceName?: string | undefined;
    csrfToken?: string | undefined;
    realmId?: string | undefined;
    authorizationCode?: string | undefined;
    entityId!: string;
    configurationJson?: string | undefined;
    configuration?: ThirdPartyConfigurationAC[] | undefined;
    startDate!: Date;
    endDate!: Date;
    reportListToFetch?: FinancialStatementsAC[] | undefined;
    bearerToken?: string | undefined;
    lastYears!: number;
    tenantId?: string | undefined;
    periodList?: string[] | undefined;

    constructor(data?: IThirdPartyServiceCallbackDataAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.thirdPartyServiceName = _data["thirdPartyServiceName"];
            this.csrfToken = _data["csrfToken"];
            this.realmId = _data["realmId"];
            this.authorizationCode = _data["authorizationCode"];
            this.entityId = _data["entityId"];
            this.configurationJson = _data["configurationJson"];
            if (Array.isArray(_data["configuration"])) {
                this.configuration = [] as any;
                for (let item of _data["configuration"])
                    this.configuration!.push(ThirdPartyConfigurationAC.fromJS(item));
            }
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            if (Array.isArray(_data["reportListToFetch"])) {
                this.reportListToFetch = [] as any;
                for (let item of _data["reportListToFetch"])
                    this.reportListToFetch!.push(FinancialStatementsAC.fromJS(item));
            }
            this.bearerToken = _data["bearerToken"];
            this.lastYears = _data["lastYears"];
            this.tenantId = _data["tenantId"];
            if (Array.isArray(_data["periodList"])) {
                this.periodList = [] as any;
                for (let item of _data["periodList"])
                    this.periodList!.push(item);
            }
        }
    }

    static fromJS(data: any): ThirdPartyServiceCallbackDataAC {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyServiceCallbackDataAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["thirdPartyServiceName"] = this.thirdPartyServiceName;
        data["csrfToken"] = this.csrfToken;
        data["realmId"] = this.realmId;
        data["authorizationCode"] = this.authorizationCode;
        data["entityId"] = this.entityId;
        data["configurationJson"] = this.configurationJson;
        if (Array.isArray(this.configuration)) {
            data["configuration"] = [];
            for (let item of this.configuration)
                data["configuration"].push(item.toJSON());
        }
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        if (Array.isArray(this.reportListToFetch)) {
            data["reportListToFetch"] = [];
            for (let item of this.reportListToFetch)
                data["reportListToFetch"].push(item.toJSON());
        }
        data["bearerToken"] = this.bearerToken;
        data["lastYears"] = this.lastYears;
        data["tenantId"] = this.tenantId;
        if (Array.isArray(this.periodList)) {
            data["periodList"] = [];
            for (let item of this.periodList)
                data["periodList"].push(item);
        }
        return data; 
    }
}

export interface IThirdPartyServiceCallbackDataAC {
    thirdPartyServiceName?: string | undefined;
    csrfToken?: string | undefined;
    realmId?: string | undefined;
    authorizationCode?: string | undefined;
    entityId: string;
    configurationJson?: string | undefined;
    configuration?: ThirdPartyConfigurationAC[] | undefined;
    startDate: Date;
    endDate: Date;
    reportListToFetch?: FinancialStatementsAC[] | undefined;
    bearerToken?: string | undefined;
    lastYears: number;
    tenantId?: string | undefined;
    periodList?: string[] | undefined;
}

export class ThirdPartyConfigurationAC implements IThirdPartyConfigurationAC {
    key?: string | undefined;
    path?: string | undefined;
    value?: string | undefined;

    constructor(data?: IThirdPartyConfigurationAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.path = _data["path"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): ThirdPartyConfigurationAC {
        data = typeof data === 'object' ? data : {};
        let result = new ThirdPartyConfigurationAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["path"] = this.path;
        data["value"] = this.value;
        return data; 
    }
}

export interface IThirdPartyConfigurationAC {
    key?: string | undefined;
    path?: string | undefined;
    value?: string | undefined;
}

export class FinancialStatementsAC implements IFinancialStatementsAC {
    reportJson?: string | undefined;
    thirdPartyWiseName?: string | undefined;
    reportName?: string | undefined;
    thirdPartyWiseCompanyName?: string | undefined;

    constructor(data?: IFinancialStatementsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reportJson = _data["reportJson"];
            this.thirdPartyWiseName = _data["thirdPartyWiseName"];
            this.reportName = _data["reportName"];
            this.thirdPartyWiseCompanyName = _data["thirdPartyWiseCompanyName"];
        }
    }

    static fromJS(data: any): FinancialStatementsAC {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialStatementsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reportJson"] = this.reportJson;
        data["thirdPartyWiseName"] = this.thirdPartyWiseName;
        data["reportName"] = this.reportName;
        data["thirdPartyWiseCompanyName"] = this.thirdPartyWiseCompanyName;
        return data; 
    }
}

export interface IFinancialStatementsAC {
    reportJson?: string | undefined;
    thirdPartyWiseName?: string | undefined;
    reportName?: string | undefined;
    thirdPartyWiseCompanyName?: string | undefined;
}

export class AuditLogFilterAC implements IAuditLogFilterAC {
    /** It contain companyId or loanId. */
    logBlockNameId!: string;
    /** Start date. */
    startDate?: Date | undefined;
    /** End date. */
    endDate?: Date | undefined;

    constructor(data?: IAuditLogFilterAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.logBlockNameId = _data["logBlockNameId"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuditLogFilterAC {
        data = typeof data === 'object' ? data : {};
        let result = new AuditLogFilterAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["logBlockNameId"] = this.logBlockNameId;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IAuditLogFilterAC {
    /** It contain companyId or loanId. */
    logBlockNameId: string;
    /** Start date. */
    startDate?: Date | undefined;
    /** End date. */
    endDate?: Date | undefined;
}

export class ConsentStatementAC implements IConsentStatementAC {
    /** Unique identifier for the consent statement. */
    id!: string;
    /** Text of the consent statement. */
    consentText?: string | undefined;
    /** Is consent enabled or not. */
    isEnabled!: boolean;

    constructor(data?: IConsentStatementAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.consentText = _data["consentText"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): ConsentStatementAC {
        data = typeof data === 'object' ? data : {};
        let result = new ConsentStatementAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["consentText"] = this.consentText;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface IConsentStatementAC {
    /** Unique identifier for the consent statement. */
    id: string;
    /** Text of the consent statement. */
    consentText?: string | undefined;
    /** Is consent enabled or not. */
    isEnabled: boolean;
}

export class BankAC implements IBankAC {
    /** Unique identifier for Bank. */
    id!: string;
    /** Name of the bank. */
    name?: string | undefined;
    /** SWIFT code of the bank. */
    swiftCode?: string | undefined;

    constructor(data?: IBankAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static fromJS(data: any): BankAC {
        data = typeof data === 'object' ? data : {};
        let result = new BankAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IBankAC {
    /** Unique identifier for Bank. */
    id: string;
    /** Name of the bank. */
    name?: string | undefined;
    /** SWIFT code of the bank. */
    swiftCode?: string | undefined;
}

export class LoanPurposeAC implements ILoanPurposeAC {
    /** Unique identifier for the purpose. */
    id!: string;
    /** Name of the purpose. */
    name?: string | undefined;
    /** Sequencial order of the purpose. */
    order!: number;
    /** Is purpose enabled or not. */
    isEnabled!: boolean;
    /** List of range type mappings. */
    loanPurposeRangeTypeMappings?: LoanPurposeRangeTypeMappingAC[] | undefined;
    /** List of sub loan purposes. */
    subLoanPurposes?: SubLoanPurposeAC[] | undefined;

    constructor(data?: ILoanPurposeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.isEnabled = _data["isEnabled"];
            if (Array.isArray(_data["loanPurposeRangeTypeMappings"])) {
                this.loanPurposeRangeTypeMappings = [] as any;
                for (let item of _data["loanPurposeRangeTypeMappings"])
                    this.loanPurposeRangeTypeMappings!.push(LoanPurposeRangeTypeMappingAC.fromJS(item));
            }
            if (Array.isArray(_data["subLoanPurposes"])) {
                this.subLoanPurposes = [] as any;
                for (let item of _data["subLoanPurposes"])
                    this.subLoanPurposes!.push(SubLoanPurposeAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoanPurposeAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanPurposeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["isEnabled"] = this.isEnabled;
        if (Array.isArray(this.loanPurposeRangeTypeMappings)) {
            data["loanPurposeRangeTypeMappings"] = [];
            for (let item of this.loanPurposeRangeTypeMappings)
                data["loanPurposeRangeTypeMappings"].push(item.toJSON());
        }
        if (Array.isArray(this.subLoanPurposes)) {
            data["subLoanPurposes"] = [];
            for (let item of this.subLoanPurposes)
                data["subLoanPurposes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILoanPurposeAC {
    /** Unique identifier for the purpose. */
    id: string;
    /** Name of the purpose. */
    name?: string | undefined;
    /** Sequencial order of the purpose. */
    order: number;
    /** Is purpose enabled or not. */
    isEnabled: boolean;
    /** List of range type mappings. */
    loanPurposeRangeTypeMappings?: LoanPurposeRangeTypeMappingAC[] | undefined;
    /** List of sub loan purposes. */
    subLoanPurposes?: SubLoanPurposeAC[] | undefined;
}

export class LoanPurposeRangeTypeMappingAC implements ILoanPurposeRangeTypeMappingAC {
    id!: string;
    loanPurposeId!: string;
    rangeTypeName?: string | undefined;
    minimum!: number;
    maximum!: number;
    stepperAmount!: number;

    constructor(data?: ILoanPurposeRangeTypeMappingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanPurposeId = _data["loanPurposeId"];
            this.rangeTypeName = _data["rangeTypeName"];
            this.minimum = _data["minimum"];
            this.maximum = _data["maximum"];
            this.stepperAmount = _data["stepperAmount"];
        }
    }

    static fromJS(data: any): LoanPurposeRangeTypeMappingAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanPurposeRangeTypeMappingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanPurposeId"] = this.loanPurposeId;
        data["rangeTypeName"] = this.rangeTypeName;
        data["minimum"] = this.minimum;
        data["maximum"] = this.maximum;
        data["stepperAmount"] = this.stepperAmount;
        return data; 
    }
}

export interface ILoanPurposeRangeTypeMappingAC {
    id: string;
    loanPurposeId: string;
    rangeTypeName?: string | undefined;
    minimum: number;
    maximum: number;
    stepperAmount: number;
}

export class SubLoanPurposeAC implements ISubLoanPurposeAC {
    id!: string;
    name?: string | undefined;
    order!: number;
    loanPurposeId!: string;
    isEnabled!: boolean;

    constructor(data?: ISubLoanPurposeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.loanPurposeId = _data["loanPurposeId"];
            this.isEnabled = _data["isEnabled"];
        }
    }

    static fromJS(data: any): SubLoanPurposeAC {
        data = typeof data === 'object' ? data : {};
        let result = new SubLoanPurposeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["loanPurposeId"] = this.loanPurposeId;
        data["isEnabled"] = this.isEnabled;
        return data; 
    }
}

export interface ISubLoanPurposeAC {
    id: string;
    name?: string | undefined;
    order: number;
    loanPurposeId: string;
    isEnabled: boolean;
}

export class ConfigurationAC implements IConfigurationAC {
    /** List of enabled sections */
    sections?: SectionAC[] | undefined;
    /** List of enabled third party services */
    thirdPartyServices?: string[] | undefined;
    /** List of the fields selected from appSettings.json file */
    appSettings?: AppSettingAC[] | undefined;

    constructor(data?: IConfigurationAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sections"])) {
                this.sections = [] as any;
                for (let item of _data["sections"])
                    this.sections!.push(SectionAC.fromJS(item));
            }
            if (Array.isArray(_data["thirdPartyServices"])) {
                this.thirdPartyServices = [] as any;
                for (let item of _data["thirdPartyServices"])
                    this.thirdPartyServices!.push(item);
            }
            if (Array.isArray(_data["appSettings"])) {
                this.appSettings = [] as any;
                for (let item of _data["appSettings"])
                    this.appSettings!.push(AppSettingAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ConfigurationAC {
        data = typeof data === 'object' ? data : {};
        let result = new ConfigurationAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sections)) {
            data["sections"] = [];
            for (let item of this.sections)
                data["sections"].push(item.toJSON());
        }
        if (Array.isArray(this.thirdPartyServices)) {
            data["thirdPartyServices"] = [];
            for (let item of this.thirdPartyServices)
                data["thirdPartyServices"].push(item);
        }
        if (Array.isArray(this.appSettings)) {
            data["appSettings"] = [];
            for (let item of this.appSettings)
                data["appSettings"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IConfigurationAC {
    /** List of enabled sections */
    sections?: SectionAC[] | undefined;
    /** List of enabled third party services */
    thirdPartyServices?: string[] | undefined;
    /** List of the fields selected from appSettings.json file */
    appSettings?: AppSettingAC[] | undefined;
}

export class SectionAC implements ISectionAC {
    /** Unique identifier of the section */
    id!: string;
    /** Section name */
    name?: string | undefined;
    /** Section order */
    order!: number;
    /** SectionId - (For internal use) */
    sectionId!: number;
    /** Parent Section - (For internal use) */
    parentId?: number | undefined;
    /** Is Added - (For internal use) */
    isAdded!: boolean;
    /** Is Updated - (For internal use) */
    isUpdated!: boolean;
    /** Is Enabled - (For internal use) */
    isEnabled!: boolean;
    /** Parent Section object */
    childSection?: SectionAC[] | undefined;

    constructor(data?: ISectionAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
            this.sectionId = _data["sectionId"];
            this.parentId = _data["parentId"];
            this.isAdded = _data["isAdded"];
            this.isUpdated = _data["isUpdated"];
            this.isEnabled = _data["isEnabled"];
            if (Array.isArray(_data["childSection"])) {
                this.childSection = [] as any;
                for (let item of _data["childSection"])
                    this.childSection!.push(SectionAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): SectionAC {
        data = typeof data === 'object' ? data : {};
        let result = new SectionAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        data["sectionId"] = this.sectionId;
        data["parentId"] = this.parentId;
        data["isAdded"] = this.isAdded;
        data["isUpdated"] = this.isUpdated;
        data["isEnabled"] = this.isEnabled;
        if (Array.isArray(this.childSection)) {
            data["childSection"] = [];
            for (let item of this.childSection)
                data["childSection"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ISectionAC {
    /** Unique identifier of the section */
    id: string;
    /** Section name */
    name?: string | undefined;
    /** Section order */
    order: number;
    /** SectionId - (For internal use) */
    sectionId: number;
    /** Parent Section - (For internal use) */
    parentId?: number | undefined;
    /** Is Added - (For internal use) */
    isAdded: boolean;
    /** Is Updated - (For internal use) */
    isUpdated: boolean;
    /** Is Enabled - (For internal use) */
    isEnabled: boolean;
    /** Parent Section object */
    childSection?: SectionAC[] | undefined;
}

export class AppSettingAC implements IAppSettingAC {
    /** Name of the field of a particular block in appsettings */
    fieldName?: string | undefined;
    /** Value of the field */
    value?: string | undefined;

    constructor(data?: IAppSettingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fieldName = _data["fieldName"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): AppSettingAC {
        data = typeof data === 'object' ? data : {};
        let result = new AppSettingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fieldName"] = this.fieldName;
        data["value"] = this.value;
        return data; 
    }
}

export interface IAppSettingAC {
    /** Name of the field of a particular block in appsettings */
    fieldName?: string | undefined;
    /** Value of the field */
    value?: string | undefined;
}

export class NAICSIndustryType implements INAICSIndustryType {
    id!: string;
    industryType!: string;
    industryCode!: string;
    naicsParentSectorId?: string | undefined;
    naicsParentSector?: NAICSIndustryType | undefined;

    constructor(data?: INAICSIndustryType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.industryType = _data["industryType"];
            this.industryCode = _data["industryCode"];
            this.naicsParentSectorId = _data["naicsParentSectorId"];
            this.naicsParentSector = _data["naicsParentSector"] ? NAICSIndustryType.fromJS(_data["naicsParentSector"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NAICSIndustryType {
        data = typeof data === 'object' ? data : {};
        let result = new NAICSIndustryType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["industryType"] = this.industryType;
        data["industryCode"] = this.industryCode;
        data["naicsParentSectorId"] = this.naicsParentSectorId;
        data["naicsParentSector"] = this.naicsParentSector ? this.naicsParentSector.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INAICSIndustryType {
    id: string;
    industryType: string;
    industryCode: string;
    naicsParentSectorId?: string | undefined;
    naicsParentSector?: NAICSIndustryType | undefined;
}

export class AwsSettings implements IAwsSettings {
    /** Base url of the document */
    baseUrl?: string | undefined;
    /** Upload Pre signed url of the document */
    uploadPreSignedUrl?: string | undefined;
    /** Pre signed url of the document */
    preSignedUrl?: string | undefined;

    constructor(data?: IAwsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.uploadPreSignedUrl = _data["uploadPreSignedUrl"];
            this.preSignedUrl = _data["preSignedUrl"];
        }
    }

    static fromJS(data: any): AwsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AwsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["uploadPreSignedUrl"] = this.uploadPreSignedUrl;
        data["preSignedUrl"] = this.preSignedUrl;
        return data; 
    }
}

export interface IAwsSettings {
    /** Base url of the document */
    baseUrl?: string | undefined;
    /** Upload Pre signed url of the document */
    uploadPreSignedUrl?: string | undefined;
    /** Pre signed url of the document */
    preSignedUrl?: string | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}