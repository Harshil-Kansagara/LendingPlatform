/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.6.0.0 (NJsonSchema v10.1.18.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class LoanApplicationService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    getAllLoanApplicationsAndItsStatusByEntityId(entityId: string): Observable<LoanApplicationListAC[]> {
        let url_ = this.baseUrl + "/api/loan/{entityId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoanApplicationsAndItsStatusByEntityId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoanApplicationsAndItsStatusByEntityId(<any>response_);
                } catch (e) {
                    return <Observable<LoanApplicationListAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanApplicationListAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoanApplicationsAndItsStatusByEntityId(response: HttpResponseBase): Observable<LoanApplicationListAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(LoanApplicationListAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanApplicationListAC[]>(<any>null);
    }

    getLoanPurposeList(): Observable<LoanPurposeListAC> {
        let url_ = this.baseUrl + "/api/loan/needs/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanPurposeList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanPurposeList(<any>response_);
                } catch (e) {
                    return <Observable<LoanPurposeListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanPurposeListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanPurposeList(response: HttpResponseBase): Observable<LoanPurposeListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanPurposeListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanPurposeListAC>(<any>null);
    }

    addLoanApplication(loanApplicationAC: LoanApplicationAC): Observable<LoanApplicationAC> {
        let url_ = this.baseUrl + "/api/loan";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanApplicationAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddLoanApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddLoanApplication(<any>response_);
                } catch (e) {
                    return <Observable<LoanApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processAddLoanApplication(response: HttpResponseBase): Observable<LoanApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanApplicationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanApplicationAC>(<any>null);
    }

    getLoanApplicationById(loanApplicationId: string): Observable<LoanApplicationAC> {
        let url_ = this.baseUrl + "/api/loan/needs/{loanApplicationId}";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanApplicationById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanApplicationById(<any>response_);
                } catch (e) {
                    return <Observable<LoanApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanApplicationById(response: HttpResponseBase): Observable<LoanApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanApplicationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanApplicationAC>(<any>null);
    }

    updateLoanApplication(loanApplicationId: string, loanApplicationAC: LoanApplicationAC): Observable<LoanApplicationAC> {
        let url_ = this.baseUrl + "/api/loan/needs/{loanApplicationId}";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanApplicationAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanApplication(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanApplication(<any>response_);
                } catch (e) {
                    return <Observable<LoanApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanApplication(response: HttpResponseBase): Observable<LoanApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanApplicationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanApplicationAC>(<any>null);
    }

    getRecommendedLoanProducts(loanApplicationId: string): Observable<LoanProductListAC> {
        let url_ = this.baseUrl + "/api/loan/{loanApplicationId}/products";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecommendedLoanProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecommendedLoanProducts(<any>response_);
                } catch (e) {
                    return <Observable<LoanProductListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanProductListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecommendedLoanProducts(response: HttpResponseBase): Observable<LoanProductListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanProductListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanProductListAC>(<any>null);
    }

    getLoanProduct(loanApplicationId: string): Observable<LoanProductAC> {
        let url_ = this.baseUrl + "/api/loan/{loanApplicationId}/product";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanProduct(<any>response_);
                } catch (e) {
                    return <Observable<LoanProductAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanProductAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanProduct(response: HttpResponseBase): Observable<LoanProductAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanProductAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanProductAC>(<any>null);
    }

    saveAndUpdateLoanProduct(loanApplicationProductMappingAC: LoanApplicationProductMappingAC): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/loan/product";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanApplicationProductMappingAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveAndUpdateLoanProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveAndUpdateLoanProduct(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSaveAndUpdateLoanProduct(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getConsents(): Observable<ConsentAC[]> {
        let url_ = this.baseUrl + "/api/loan/consents";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetConsents(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetConsents(<any>response_);
                } catch (e) {
                    return <Observable<ConsentAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ConsentAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetConsents(response: HttpResponseBase): Observable<ConsentAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(ConsentAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ConsentAC[]>(<any>null);
    }

    saveLoanConsentOfUser(consent: EntityLoanApplicationConsentAC): Observable<EntityLoanApplicationConsentAC> {
        let url_ = this.baseUrl + "/api/loan/consents";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(consent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveLoanConsentOfUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveLoanConsentOfUser(<any>response_);
                } catch (e) {
                    return <Observable<EntityLoanApplicationConsentAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityLoanApplicationConsentAC>><any>_observableThrow(response_);
        }));
    }

    protected processSaveLoanConsentOfUser(response: HttpResponseBase): Observable<EntityLoanApplicationConsentAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityLoanApplicationConsentAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityLoanApplicationConsentAC>(<any>null);
    }

    getLoanConsentsByLoanApplicationId(loanApplicationId: string): Observable<EntityLoanApplicationConsentAC[]> {
        let url_ = this.baseUrl + "/api/loan/{loanApplicationId}/consents";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanConsentsByLoanApplicationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanConsentsByLoanApplicationId(<any>response_);
                } catch (e) {
                    return <Observable<EntityLoanApplicationConsentAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityLoanApplicationConsentAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanConsentsByLoanApplicationId(response: HttpResponseBase): Observable<EntityLoanApplicationConsentAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityLoanApplicationConsentAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityLoanApplicationConsentAC[]>(<any>null);
    }

    sendConsentReminderEmails(): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/loan/consents/reminder-email";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendConsentReminderEmails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendConsentReminderEmails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processSendConsentReminderEmails(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    postBankDetails(loanEntityBankDetailsAC: LoanEntityBankDetailsAC, loanApplicationId: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/loan/{loanApplicationId}/bank";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanEntityBankDetailsAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostBankDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostBankDetails(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processPostBankDetails(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getListOfBanks(): Observable<BankAC[]> {
        let url_ = this.baseUrl + "/api/loan/banks";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetListOfBanks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetListOfBanks(<any>response_);
                } catch (e) {
                    return <Observable<BankAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetListOfBanks(response: HttpResponseBase): Observable<BankAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAC[]>(<any>null);
    }

    getAllLoans(page: number | undefined, order: string | null | undefined, field: string | null | undefined, searchLoanNumber: string | null | undefined, filterDate: Date | undefined, filterCompanyName: string | null | undefined, filterMoneyNeeds: number | null | undefined, filterLoanPurpose: string | null | undefined, filterLoanStatus: LoanApplicationStatusType | null | undefined, pageCount: number | undefined): Observable<PagedLoanApplicationAC> {
        let url_ = this.baseUrl + "/api/bank/loan?";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "Page=" + encodeURIComponent("" + page) + "&";
        if (order !== undefined && order !== null)
            url_ += "Order=" + encodeURIComponent("" + order) + "&";
        if (field !== undefined && field !== null)
            url_ += "Field=" + encodeURIComponent("" + field) + "&";
        if (searchLoanNumber !== undefined && searchLoanNumber !== null)
            url_ += "SearchLoanNumber=" + encodeURIComponent("" + searchLoanNumber) + "&";
        if (filterDate === null)
            throw new Error("The parameter 'filterDate' cannot be null.");
        else if (filterDate !== undefined)
            url_ += "FilterDate=" + encodeURIComponent(filterDate ? "" + filterDate.toJSON() : "") + "&";
        if (filterCompanyName !== undefined && filterCompanyName !== null)
            url_ += "FilterCompanyName=" + encodeURIComponent("" + filterCompanyName) + "&";
        if (filterMoneyNeeds !== undefined && filterMoneyNeeds !== null)
            url_ += "FilterMoneyNeeds=" + encodeURIComponent("" + filterMoneyNeeds) + "&";
        if (filterLoanPurpose !== undefined && filterLoanPurpose !== null)
            url_ += "FilterLoanPurpose=" + encodeURIComponent("" + filterLoanPurpose) + "&";
        if (filterLoanStatus !== undefined && filterLoanStatus !== null)
            url_ += "FilterLoanStatus=" + encodeURIComponent("" + filterLoanStatus) + "&";
        if (pageCount === null)
            throw new Error("The parameter 'pageCount' cannot be null.");
        else if (pageCount !== undefined)
            url_ += "PageCount=" + encodeURIComponent("" + pageCount) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllLoans(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllLoans(<any>response_);
                } catch (e) {
                    return <Observable<PagedLoanApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedLoanApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllLoans(response: HttpResponseBase): Observable<PagedLoanApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedLoanApplicationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedLoanApplicationAC>(<any>null);
    }

    getLoanDetailById(loanApplicationId: string): Observable<LoanApplicationAC> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanDetailById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanDetailById(<any>response_);
                } catch (e) {
                    return <Observable<LoanApplicationAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanApplicationAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanDetailById(response: HttpResponseBase): Observable<LoanApplicationAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanApplicationAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanApplicationAC>(<any>null);
    }

    getCompanyInfoByLoanId(loanApplicationId: string): Observable<CompanyAC> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/company";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyInfoByLoanId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyInfoByLoanId(<any>response_);
                } catch (e) {
                    return <Observable<CompanyAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyInfoByLoanId(response: HttpResponseBase): Observable<CompanyAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyAC>(<any>null);
    }

    updateLoanStatus(loanApplicationStatusAC: LoanApplicationStatusAC, loanApplicationId: string, status: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/{status}";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined.");
        url_ = url_.replace("{status}", encodeURIComponent("" + status));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loanApplicationStatusAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLoanStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLoanStatus(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLoanStatus(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getFinancialInfoByLoanId(entityId: string | undefined, loanApplicationId: string, userId: string | undefined): Observable<EntityFinanceAC[]> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/company/finances/statements?";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialInfoByLoanId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialInfoByLoanId(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinancialInfoByLoanId(response: HttpResponseBase): Observable<EntityFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC[]>(<any>null);
    }

    getFinancialInfoTaxesInfoByLoanId(loanApplicationId: string): Observable<EntityFinanceAC> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/company/finances/taxes";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialInfoTaxesInfoByLoanId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialInfoTaxesInfoByLoanId(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinancialInfoTaxesInfoByLoanId(response: HttpResponseBase): Observable<EntityFinanceAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityFinanceAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC>(<any>null);
    }

    getDocument(documentId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/bank/loan/document/{documentId}";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocument(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocument(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getLoanProductByLoanId(loanApplicationId: string): Observable<LoanProductAC> {
        let url_ = this.baseUrl + "/api/bank/loan/company/finances/{loanApplicationId}/product";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanProductByLoanId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanProductByLoanId(<any>response_);
                } catch (e) {
                    return <Observable<LoanProductAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<LoanProductAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanProductByLoanId(response: HttpResponseBase): Observable<LoanProductAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoanProductAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LoanProductAC>(<any>null);
    }

    getLoanConsentByLoanId(loanApplicationId: string): Observable<EntityLoanApplicationConsentAC[]> {
        let url_ = this.baseUrl + "/api/bank/loan/company/finances/{loanApplicationId}/consent";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetLoanConsentByLoanId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetLoanConsentByLoanId(<any>response_);
                } catch (e) {
                    return <Observable<EntityLoanApplicationConsentAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityLoanApplicationConsentAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetLoanConsentByLoanId(response: HttpResponseBase): Observable<EntityLoanApplicationConsentAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityLoanApplicationConsentAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityLoanApplicationConsentAC[]>(<any>null);
    }

    getProviderBankList(loanApplicationId: string): Observable<ProviderBankListAC> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/company/finances/provider-banks";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProviderBankList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProviderBankList(<any>response_);
                } catch (e) {
                    return <Observable<ProviderBankListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderBankListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetProviderBankList(response: HttpResponseBase): Observable<ProviderBankListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProviderBankListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderBankListAC>(<any>null);
    }

    getBankAccountTransactionList(providerBankId: string): Observable<BankAccountTransactionAC[]> {
        let url_ = this.baseUrl + "/api/bank/loan/company/finances/account-transactions/{providerBankId}";
        if (providerBankId === undefined || providerBankId === null)
            throw new Error("The parameter 'providerBankId' must be defined.");
        url_ = url_.replace("{providerBankId}", encodeURIComponent("" + providerBankId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccountTransactionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccountTransactionList(<any>response_);
                } catch (e) {
                    return <Observable<BankAccountTransactionAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAccountTransactionAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccountTransactionList(response: HttpResponseBase): Observable<BankAccountTransactionAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountTransactionAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountTransactionAC[]>(<any>null);
    }

    getInvoices(loanApplicationId: string): Observable<InvoiceListAC> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/company/finances/invoices";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoices(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoices(response: HttpResponseBase): Observable<InvoiceListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListAC>(<any>null);
    }

    evaluateLoan(loanApplicationId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/bank/loan/{loanApplicationId}/evaluate";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEvaluateLoan(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEvaluateLoan(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processEvaluateLoan(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }
}

@Injectable()
export class CompanyInfoService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    getAllCompaniesOfLoggedInUser(): Observable<CompanyAC[]> {
        let url_ = this.baseUrl + "/api/company";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCompaniesOfLoggedInUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCompaniesOfLoggedInUser(<any>response_);
                } catch (e) {
                    return <Observable<CompanyAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCompaniesOfLoggedInUser(response: HttpResponseBase): Observable<CompanyAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(CompanyAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyAC[]>(<any>null);
    }

    addCompanyInfo(companyInfo: CompanyInfoAC): Observable<CompanyInfoAC> {
        let url_ = this.baseUrl + "/api/company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(companyInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCompanyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCompanyInfo(<any>response_);
                } catch (e) {
                    return <Observable<CompanyInfoAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyInfoAC>><any>_observableThrow(response_);
        }));
    }

    protected processAddCompanyInfo(response: HttpResponseBase): Observable<CompanyInfoAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyInfoAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyInfoAC>(<any>null);
    }

    updateCompanyInfo(companyInfo: CompanyInfoAC): Observable<CompanyInfoAC> {
        let url_ = this.baseUrl + "/api/company";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(companyInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCompanyInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCompanyInfo(<any>response_);
                } catch (e) {
                    return <Observable<CompanyInfoAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyInfoAC>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCompanyInfo(response: HttpResponseBase): Observable<CompanyInfoAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyInfoAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyInfoAC>(<any>null);
    }

    getCompanyInfoOption(): Observable<CompanyInfoOptionAC> {
        let url_ = this.baseUrl + "/api/company/options";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyInfoOption(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyInfoOption(<any>response_);
                } catch (e) {
                    return <Observable<CompanyInfoOptionAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyInfoOptionAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyInfoOption(response: HttpResponseBase): Observable<CompanyInfoOptionAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyInfoOptionAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyInfoOptionAC>(<any>null);
    }

    getCompanyInfoByLoanApplicationId(loanApplicationId: string): Observable<CompanyAC> {
        let url_ = this.baseUrl + "/api/company/{loanApplicationId}/company";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyInfoByLoanApplicationId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyInfoByLoanApplicationId(<any>response_);
                } catch (e) {
                    return <Observable<CompanyAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompanyAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyInfoByLoanApplicationId(response: HttpResponseBase): Observable<CompanyAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CompanyAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompanyAC>(<any>null);
    }

    getCompanyUsers(entityId: string): Observable<UserAC[]> {
        let url_ = this.baseUrl + "/api/company/{entityId}/users";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCompanyUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCompanyUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCompanyUsers(response: HttpResponseBase): Observable<UserAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(UserAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAC[]>(<any>null);
    }

    getAuthorizationUrl(entityId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/company/finances/statements/quickbooks/auth-url?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuthorizationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuthorizationUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuthorizationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getQuickBooksTokens(code: string | null | undefined, realmId: string | null | undefined, state: string | undefined, loanApplicationId: string | undefined): Observable<EntityFinanceAC[]> {
        let url_ = this.baseUrl + "/api/company/finances/statements/quickbooks/redirect?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (realmId !== undefined && realmId !== null)
            url_ += "realmId=" + encodeURIComponent("" + realmId) + "&";
        if (state === null)
            throw new Error("The parameter 'state' cannot be null.");
        else if (state !== undefined)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' cannot be null.");
        else if (loanApplicationId !== undefined)
            url_ += "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetQuickBooksTokens(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetQuickBooksTokens(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetQuickBooksTokens(response: HttpResponseBase): Observable<EntityFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC[]>(<any>null);
    }

    getFinancialInfoStatements(entityId: string | undefined, loanApplicationId: string | undefined): Observable<EntityFinanceAC[]> {
        let url_ = this.baseUrl + "/api/company/finances/statements?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' cannot be null.");
        else if (loanApplicationId !== undefined)
            url_ += "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialInfoStatements(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialInfoStatements(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinancialInfoStatements(response: HttpResponseBase): Observable<EntityFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC[]>(<any>null);
    }

    getDefaultEmptyManualReport(entityId: string | undefined, loanApplicationId: string | undefined): Observable<EntityFinanceAC[]> {
        let url_ = this.baseUrl + "/api/company/finances/statements/manual/structure?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' cannot be null.");
        else if (loanApplicationId !== undefined)
            url_ += "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDefaultEmptyManualReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDefaultEmptyManualReport(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDefaultEmptyManualReport(response: HttpResponseBase): Observable<EntityFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC[]>(<any>null);
    }

    postManualFinancials(entityFinances: EntityFinanceAC[]): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/company/finances/statements/manual";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entityFinances);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostManualFinancials(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostManualFinancials(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processPostManualFinancials(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getXeroLoginUrl(entityId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/company/finances/statements/xero/auth-url?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetXeroLoginUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetXeroLoginUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetXeroLoginUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getFinancialInfoReport(code: string | null | undefined, state: string | null | undefined, loanApplicationId: string | undefined): Observable<EntityFinanceAC[]> {
        let url_ = this.baseUrl + "/api/company/finances/statements/xero/redirect?";
        if (code !== undefined && code !== null)
            url_ += "code=" + encodeURIComponent("" + code) + "&";
        if (state !== undefined && state !== null)
            url_ += "state=" + encodeURIComponent("" + state) + "&";
        if (loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' cannot be null.");
        else if (loanApplicationId !== undefined)
            url_ += "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFinancialInfoReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFinancialInfoReport(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetFinancialInfoReport(response: HttpResponseBase): Observable<EntityFinanceAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(EntityFinanceAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC[]>(<any>null);
    }

    getTaxReturnInfo(loanApplicationId: string): Observable<EntityFinanceAC> {
        let url_ = this.baseUrl + "/api/company/finances/statements/taxes/{loanApplicationId}";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaxReturnInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaxReturnInfo(<any>response_);
                } catch (e) {
                    return <Observable<EntityFinanceAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityFinanceAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaxReturnInfo(response: HttpResponseBase): Observable<EntityFinanceAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityFinanceAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityFinanceAC>(<any>null);
    }

    postTaxReturn(entityFinancialTaxReturn: EntityFinanceAC): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/company/finances/statements/taxes";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entityFinancialTaxReturn);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostTaxReturn(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostTaxReturn(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processPostTaxReturn(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getDocument(documentId: string): Observable<string> {
        let url_ = this.baseUrl + "/api/company/document/{documentId}";
        if (documentId === undefined || documentId === null)
            throw new Error("The parameter 'documentId' must be defined.");
        url_ = url_.replace("{documentId}", encodeURIComponent("" + documentId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocument(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocument(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    uploadDocument(file: FileParameter | null | undefined): Observable<AwsSettings> {
        let url_ = this.baseUrl + "/api/company/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("file", file.data, file.fileName ? file.fileName : "file");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadDocument(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadDocument(<any>response_);
                } catch (e) {
                    return <Observable<AwsSettings>><any>_observableThrow(e);
                }
            } else
                return <Observable<AwsSettings>><any>_observableThrow(response_);
        }));
    }

    protected processUploadDocument(response: HttpResponseBase): Observable<AwsSettings> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AwsSettings.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AwsSettings>(<any>null);
    }

    getPayPalAuthorizationUrl(entityId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/company/finances/invoices/paypal/auth-url?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPayPalAuthorizationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPayPalAuthorizationUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPayPalAuthorizationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getStripeAuthorizationUrl(entityId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/company/finances/invoices/stripe/auth-url?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStripeAuthorizationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStripeAuthorizationUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetStripeAuthorizationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getSquareAuthorizationUrl(entityId: string | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/company/finances/invoices/square/auth-url?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSquareAuthorizationUrl(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSquareAuthorizationUrl(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetSquareAuthorizationUrl(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getInvoices(entityId: string | undefined, loanApplicationId: string | undefined): Observable<InvoiceListAC> {
        let url_ = this.baseUrl + "/api/company/finances/invoices?";
        if (entityId === null)
            throw new Error("The parameter 'entityId' cannot be null.");
        else if (entityId !== undefined)
            url_ += "entityId=" + encodeURIComponent("" + entityId) + "&";
        if (loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' cannot be null.");
        else if (loanApplicationId !== undefined)
            url_ += "loanApplicationId=" + encodeURIComponent("" + loanApplicationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInvoices(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetInvoices(response: HttpResponseBase): Observable<InvoiceListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListAC>(<any>null);
    }

    saveInvoices(invoiceRequest: InvoiceRequestParametersAC): Observable<InvoiceListAC> {
        let url_ = this.baseUrl + "/api/company/finances/invoices";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(invoiceRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveInvoices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveInvoices(<any>response_);
                } catch (e) {
                    return <Observable<InvoiceListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<InvoiceListAC>><any>_observableThrow(response_);
        }));
    }

    protected processSaveInvoices(response: HttpResponseBase): Observable<InvoiceListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = InvoiceListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InvoiceListAC>(<any>null);
    }

    getYodleeFastLink(entityId: string): Observable<YodleeFastLinkAC> {
        let url_ = this.baseUrl + "/api/company/finances/yodlee/fastlink/{entityId}";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetYodleeFastLink(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetYodleeFastLink(<any>response_);
                } catch (e) {
                    return <Observable<YodleeFastLinkAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<YodleeFastLinkAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetYodleeFastLink(response: HttpResponseBase): Observable<YodleeFastLinkAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = YodleeFastLinkAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<YodleeFastLinkAC>(<any>null);
    }

    getProviderBankList(loanApplicationId: string): Observable<ProviderBankListAC> {
        let url_ = this.baseUrl + "/api/company/finances/provider-banks/{loanApplicationId}";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProviderBankList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProviderBankList(<any>response_);
                } catch (e) {
                    return <Observable<ProviderBankListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderBankListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetProviderBankList(response: HttpResponseBase): Observable<ProviderBankListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProviderBankListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderBankListAC>(<any>null);
    }

    getBankAccountTransactionList(providerBankId: string): Observable<BankAccountTransactionAC[]> {
        let url_ = this.baseUrl + "/api/company/finances/account-transactions/{providerBankId}";
        if (providerBankId === undefined || providerBankId === null)
            throw new Error("The parameter 'providerBankId' must be defined.");
        url_ = url_.replace("{providerBankId}", encodeURIComponent("" + providerBankId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBankAccountTransactionList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBankAccountTransactionList(<any>response_);
                } catch (e) {
                    return <Observable<BankAccountTransactionAC[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<BankAccountTransactionAC[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetBankAccountTransactionList(response: HttpResponseBase): Observable<BankAccountTransactionAC[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(BankAccountTransactionAC.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BankAccountTransactionAC[]>(<any>null);
    }

    addAccountTransactions(entityBankAccountsMappingAC: EntityBankAccountsMappingAC): Observable<ProviderBankListAC> {
        let url_ = this.baseUrl + "/api/company/finances/account-transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entityBankAccountsMappingAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAccountTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAccountTransactions(<any>response_);
                } catch (e) {
                    return <Observable<ProviderBankListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderBankListAC>><any>_observableThrow(response_);
        }));
    }

    protected processAddAccountTransactions(response: HttpResponseBase): Observable<ProviderBankListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProviderBankListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderBankListAC>(<any>null);
    }

    getPlaidLinkToken(): Observable<string> {
        let url_ = this.baseUrl + "/api/company/finances/bank-transactions/plaid/linktoken";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlaidLinkToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlaidLinkToken(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlaidLinkToken(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getPlaidBankTransactions(entityBankAccountsMappingAC: EntityBankAccountsMappingAC): Observable<ProviderBankListAC> {
        let url_ = this.baseUrl + "/api/company/finances/bank-transactions/plaid/transactions";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entityBankAccountsMappingAC);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlaidBankTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlaidBankTransactions(<any>response_);
                } catch (e) {
                    return <Observable<ProviderBankListAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProviderBankListAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlaidBankTransactions(response: HttpResponseBase): Observable<ProviderBankListAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProviderBankListAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProviderBankListAC>(<any>null);
    }
}

@Injectable()
export class EntityService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    getAddress(entityId: string): Observable<AddressAC> {
        let url_ = this.baseUrl + "/api/entity/{entityId}/address";
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAddress(<any>response_);
                } catch (e) {
                    return <Observable<AddressAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<AddressAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetAddress(response: HttpResponseBase): Observable<AddressAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddressAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AddressAC>(<any>null);
    }

    getCreditReportDetails(loanApplicationId: string, entityId: string): Observable<EntityCreditReportJsonAC> {
        let url_ = this.baseUrl + "/api/bank/entity/{loanApplicationId}/{entityId}/credit-report";
        if (loanApplicationId === undefined || loanApplicationId === null)
            throw new Error("The parameter 'loanApplicationId' must be defined.");
        url_ = url_.replace("{loanApplicationId}", encodeURIComponent("" + loanApplicationId));
        if (entityId === undefined || entityId === null)
            throw new Error("The parameter 'entityId' must be defined.");
        url_ = url_.replace("{entityId}", encodeURIComponent("" + entityId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCreditReportDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCreditReportDetails(<any>response_);
                } catch (e) {
                    return <Observable<EntityCreditReportJsonAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntityCreditReportJsonAC>><any>_observableThrow(response_);
        }));
    }

    protected processGetCreditReportDetails(response: HttpResponseBase): Observable<EntityCreditReportJsonAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = EntityCreditReportJsonAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntityCreditReportJsonAC>(<any>null);
    }
}

@Injectable()
export class UserService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "https://localhost:44311";
    }

    get(): Observable<UserAC> {
        let url_ = this.baseUrl + "/api/user/me";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<UserAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserAC>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<UserAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserAC>(<any>null);
    }

    saveUserInfoAddress(userInfo: UserInfoAddressAC): Observable<UserInfoAddressAC> {
        let url_ = this.baseUrl + "/api/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userInfo);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveUserInfoAddress(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveUserInfoAddress(<any>response_);
                } catch (e) {
                    return <Observable<UserInfoAddressAC>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserInfoAddressAC>><any>_observableThrow(response_);
        }));
    }

    protected processSaveUserInfoAddress(response: HttpResponseBase): Observable<UserInfoAddressAC> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserInfoAddressAC.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserInfoAddressAC>(<any>null);
    }
}

export class LoanApplicationListAC implements ILoanApplicationListAC {
    loanApplicationId!: string;
    loanApplicationNumber!: string;
    loanApplicationStatusAC!: LoanApplicationStatusAC;
    isReadOnlyMode!: boolean;
    entityBankDetailsAC?: LoanEntityBankDetailsAC | undefined;

    constructor(data?: ILoanApplicationListAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.loanApplicationStatusAC = new LoanApplicationStatusAC();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanApplicationId = _data["loanApplicationId"];
            this.loanApplicationNumber = _data["loanApplicationNumber"];
            this.loanApplicationStatusAC = _data["loanApplicationStatusAC"] ? LoanApplicationStatusAC.fromJS(_data["loanApplicationStatusAC"]) : new LoanApplicationStatusAC();
            this.isReadOnlyMode = _data["isReadOnlyMode"];
            this.entityBankDetailsAC = _data["entityBankDetailsAC"] ? LoanEntityBankDetailsAC.fromJS(_data["entityBankDetailsAC"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoanApplicationListAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanApplicationListAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanApplicationId"] = this.loanApplicationId;
        data["loanApplicationNumber"] = this.loanApplicationNumber;
        data["loanApplicationStatusAC"] = this.loanApplicationStatusAC ? this.loanApplicationStatusAC.toJSON() : <any>undefined;
        data["isReadOnlyMode"] = this.isReadOnlyMode;
        data["entityBankDetailsAC"] = this.entityBankDetailsAC ? this.entityBankDetailsAC.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILoanApplicationListAC {
    loanApplicationId: string;
    loanApplicationNumber: string;
    loanApplicationStatusAC: LoanApplicationStatusAC;
    isReadOnlyMode: boolean;
    entityBankDetailsAC?: LoanEntityBankDetailsAC | undefined;
}

export class LoanApplicationStatusAC implements ILoanApplicationStatusAC {
    id?: string | undefined;
    status!: LoanApplicationStatusType;
    sectionName!: string;
    loanApplicationId!: string;
    comments?: string | undefined;
    loanStatus?: string | undefined;

    constructor(data?: ILoanApplicationStatusAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.sectionName = _data["sectionName"];
            this.loanApplicationId = _data["loanApplicationId"];
            this.comments = _data["comments"];
            this.loanStatus = _data["loanStatus"];
        }
    }

    static fromJS(data: any): LoanApplicationStatusAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanApplicationStatusAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["sectionName"] = this.sectionName;
        data["loanApplicationId"] = this.loanApplicationId;
        data["comments"] = this.comments;
        data["loanStatus"] = this.loanStatus;
        return data; 
    }
}

export interface ILoanApplicationStatusAC {
    id?: string | undefined;
    status: LoanApplicationStatusType;
    sectionName: string;
    loanApplicationId: string;
    comments?: string | undefined;
    loanStatus?: string | undefined;
}

export enum LoanApplicationStatusType {
    Draft = 0,
    Submitted = 1,
    Approved = 2,
    Rejected = 3,
    Referral = 4,
    EvaluationFailure = 5,
}

export class LoanEntityBankDetailsAC implements ILoanEntityBankDetailsAC {
    loanApplicationId!: string;
    loanAmountDepositeeBank?: EntityBankDetailsAC | undefined;
    emiDeducteeBank?: EntityBankDetailsAC | undefined;

    constructor(data?: ILoanEntityBankDetailsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanApplicationId = _data["loanApplicationId"];
            this.loanAmountDepositeeBank = _data["loanAmountDepositeeBank"] ? EntityBankDetailsAC.fromJS(_data["loanAmountDepositeeBank"]) : <any>undefined;
            this.emiDeducteeBank = _data["emiDeducteeBank"] ? EntityBankDetailsAC.fromJS(_data["emiDeducteeBank"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoanEntityBankDetailsAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanEntityBankDetailsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanApplicationId"] = this.loanApplicationId;
        data["loanAmountDepositeeBank"] = this.loanAmountDepositeeBank ? this.loanAmountDepositeeBank.toJSON() : <any>undefined;
        data["emiDeducteeBank"] = this.emiDeducteeBank ? this.emiDeducteeBank.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILoanEntityBankDetailsAC {
    loanApplicationId: string;
    loanAmountDepositeeBank?: EntityBankDetailsAC | undefined;
    emiDeducteeBank?: EntityBankDetailsAC | undefined;
}

export class EntityBankDetailsAC implements IEntityBankDetailsAC {
    bankId!: string;
    accountNumber?: string | undefined;
    bankName?: string | undefined;
    swiftCode?: string | undefined;

    constructor(data?: IEntityBankDetailsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bankId = _data["bankId"];
            this.accountNumber = _data["accountNumber"];
            this.bankName = _data["bankName"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static fromJS(data: any): EntityBankDetailsAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityBankDetailsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bankId"] = this.bankId;
        data["accountNumber"] = this.accountNumber;
        data["bankName"] = this.bankName;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IEntityBankDetailsAC {
    bankId: string;
    accountNumber?: string | undefined;
    bankName?: string | undefined;
    swiftCode?: string | undefined;
}

export class LoanPurposeListAC implements ILoanPurposeListAC {
    loanPurposes?: LoanPurposeAC[] | undefined;

    constructor(data?: ILoanPurposeListAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["loanPurposes"])) {
                this.loanPurposes = [] as any;
                for (let item of _data["loanPurposes"])
                    this.loanPurposes!.push(LoanPurposeAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoanPurposeListAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanPurposeListAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.loanPurposes)) {
            data["loanPurposes"] = [];
            for (let item of this.loanPurposes)
                data["loanPurposes"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILoanPurposeListAC {
    loanPurposes?: LoanPurposeAC[] | undefined;
}

export class LoanPurposeAC implements ILoanPurposeAC {
    id!: string;
    name!: string;
    order!: number;

    constructor(data?: ILoanPurposeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): LoanPurposeAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanPurposeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        return data; 
    }
}

export interface ILoanPurposeAC {
    id: string;
    name: string;
    order: number;
}

export class LoanApplicationAC implements ILoanApplicationAC {
    id?: string | undefined;
    userId!: string;
    loanApplicationStatusId!: string;
    loanAmount!: number;
    loanPurposeId!: string;
    loanPeriod!: number;
    loanApplicationNumber?: string | undefined;
    loanApplicationStatusAC!: LoanApplicationStatusAC;
    companyName?: string | undefined;
    moneyNeeds!: number;
    loanPurpose?: string | undefined;
    createdOn!: Date;
    isLoanProductSelected!: boolean;
    loanStatus!: LoanApplicationStatusType;
    entityFinances?: EntityFinanceAC[] | undefined;
    entityBankDetailsAC?: LoanEntityBankDetailsAC | undefined;

    constructor(data?: ILoanApplicationAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.loanApplicationStatusAC = new LoanApplicationStatusAC();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.loanApplicationStatusId = _data["loanApplicationStatusId"];
            this.loanAmount = _data["loanAmount"];
            this.loanPurposeId = _data["loanPurposeId"];
            this.loanPeriod = _data["loanPeriod"];
            this.loanApplicationNumber = _data["loanApplicationNumber"];
            this.loanApplicationStatusAC = _data["loanApplicationStatusAC"] ? LoanApplicationStatusAC.fromJS(_data["loanApplicationStatusAC"]) : new LoanApplicationStatusAC();
            this.companyName = _data["companyName"];
            this.moneyNeeds = _data["moneyNeeds"];
            this.loanPurpose = _data["loanPurpose"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.isLoanProductSelected = _data["isLoanProductSelected"];
            this.loanStatus = _data["loanStatus"];
            if (Array.isArray(_data["entityFinances"])) {
                this.entityFinances = [] as any;
                for (let item of _data["entityFinances"])
                    this.entityFinances!.push(EntityFinanceAC.fromJS(item));
            }
            this.entityBankDetailsAC = _data["entityBankDetailsAC"] ? LoanEntityBankDetailsAC.fromJS(_data["entityBankDetailsAC"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoanApplicationAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanApplicationAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["loanApplicationStatusId"] = this.loanApplicationStatusId;
        data["loanAmount"] = this.loanAmount;
        data["loanPurposeId"] = this.loanPurposeId;
        data["loanPeriod"] = this.loanPeriod;
        data["loanApplicationNumber"] = this.loanApplicationNumber;
        data["loanApplicationStatusAC"] = this.loanApplicationStatusAC ? this.loanApplicationStatusAC.toJSON() : <any>undefined;
        data["companyName"] = this.companyName;
        data["moneyNeeds"] = this.moneyNeeds;
        data["loanPurpose"] = this.loanPurpose;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["isLoanProductSelected"] = this.isLoanProductSelected;
        data["loanStatus"] = this.loanStatus;
        if (Array.isArray(this.entityFinances)) {
            data["entityFinances"] = [];
            for (let item of this.entityFinances)
                data["entityFinances"].push(item.toJSON());
        }
        data["entityBankDetailsAC"] = this.entityBankDetailsAC ? this.entityBankDetailsAC.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILoanApplicationAC {
    id?: string | undefined;
    userId: string;
    loanApplicationStatusId: string;
    loanAmount: number;
    loanPurposeId: string;
    loanPeriod: number;
    loanApplicationNumber?: string | undefined;
    loanApplicationStatusAC: LoanApplicationStatusAC;
    companyName?: string | undefined;
    moneyNeeds: number;
    loanPurpose?: string | undefined;
    createdOn: Date;
    isLoanProductSelected: boolean;
    loanStatus: LoanApplicationStatusType;
    entityFinances?: EntityFinanceAC[] | undefined;
    entityBankDetailsAC?: LoanEntityBankDetailsAC | undefined;
}

export class EntityFinanceAC implements IEntityFinanceAC {
    id!: string;
    entityId!: string;
    financialInformationReports?: QuickbooksReportAC[] | undefined;
    financialStatementId!: string;
    loanApplicationId!: string;
    entityFinanceYearlyMappings?: EntityFinanceYearlyMappingAC[] | undefined;
    loanApplicationNumber?: string | undefined;
    reportName?: string | undefined;
    quickbooksTokens?: QuickbooksTokenAC | undefined;
    isCallFromRedirect!: boolean;
    financialStatement?: string | undefined;
    userId!: string;
    financialInformationJson?: string | undefined;
    accessToken?: string | undefined;
    namedReportType!: NamedReportType;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    lastYears!: number;
    financialInformationFrom?: FinancialInformationFrom | undefined;
    financialAccountTypeACs?: FinancialAccountTypeAC[] | undefined;
    isEmptyReport!: boolean;

    constructor(data?: IEntityFinanceAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.entityId = _data["entityId"];
            if (Array.isArray(_data["financialInformationReports"])) {
                this.financialInformationReports = [] as any;
                for (let item of _data["financialInformationReports"])
                    this.financialInformationReports!.push(QuickbooksReportAC.fromJS(item));
            }
            this.financialStatementId = _data["financialStatementId"];
            this.loanApplicationId = _data["loanApplicationId"];
            if (Array.isArray(_data["entityFinanceYearlyMappings"])) {
                this.entityFinanceYearlyMappings = [] as any;
                for (let item of _data["entityFinanceYearlyMappings"])
                    this.entityFinanceYearlyMappings!.push(EntityFinanceYearlyMappingAC.fromJS(item));
            }
            this.loanApplicationNumber = _data["loanApplicationNumber"];
            this.reportName = _data["reportName"];
            this.quickbooksTokens = _data["quickbooksTokens"] ? QuickbooksTokenAC.fromJS(_data["quickbooksTokens"]) : <any>undefined;
            this.isCallFromRedirect = _data["isCallFromRedirect"];
            this.financialStatement = _data["financialStatement"];
            this.userId = _data["userId"];
            this.financialInformationJson = _data["financialInformationJson"];
            this.accessToken = _data["accessToken"];
            this.namedReportType = _data["namedReportType"];
            this.fromDate = _data["fromDate"] ? new Date(_data["fromDate"].toString()) : <any>undefined;
            this.toDate = _data["toDate"] ? new Date(_data["toDate"].toString()) : <any>undefined;
            this.lastYears = _data["lastYears"];
            this.financialInformationFrom = _data["financialInformationFrom"];
            if (Array.isArray(_data["financialAccountTypeACs"])) {
                this.financialAccountTypeACs = [] as any;
                for (let item of _data["financialAccountTypeACs"])
                    this.financialAccountTypeACs!.push(FinancialAccountTypeAC.fromJS(item));
            }
            this.isEmptyReport = _data["isEmptyReport"];
        }
    }

    static fromJS(data: any): EntityFinanceAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFinanceAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["entityId"] = this.entityId;
        if (Array.isArray(this.financialInformationReports)) {
            data["financialInformationReports"] = [];
            for (let item of this.financialInformationReports)
                data["financialInformationReports"].push(item.toJSON());
        }
        data["financialStatementId"] = this.financialStatementId;
        data["loanApplicationId"] = this.loanApplicationId;
        if (Array.isArray(this.entityFinanceYearlyMappings)) {
            data["entityFinanceYearlyMappings"] = [];
            for (let item of this.entityFinanceYearlyMappings)
                data["entityFinanceYearlyMappings"].push(item.toJSON());
        }
        data["loanApplicationNumber"] = this.loanApplicationNumber;
        data["reportName"] = this.reportName;
        data["quickbooksTokens"] = this.quickbooksTokens ? this.quickbooksTokens.toJSON() : <any>undefined;
        data["isCallFromRedirect"] = this.isCallFromRedirect;
        data["financialStatement"] = this.financialStatement;
        data["userId"] = this.userId;
        data["financialInformationJson"] = this.financialInformationJson;
        data["accessToken"] = this.accessToken;
        data["namedReportType"] = this.namedReportType;
        data["fromDate"] = this.fromDate ? this.fromDate.toISOString() : <any>undefined;
        data["toDate"] = this.toDate ? this.toDate.toISOString() : <any>undefined;
        data["lastYears"] = this.lastYears;
        data["financialInformationFrom"] = this.financialInformationFrom;
        if (Array.isArray(this.financialAccountTypeACs)) {
            data["financialAccountTypeACs"] = [];
            for (let item of this.financialAccountTypeACs)
                data["financialAccountTypeACs"].push(item.toJSON());
        }
        data["isEmptyReport"] = this.isEmptyReport;
        return data; 
    }
}

export interface IEntityFinanceAC {
    id: string;
    entityId: string;
    financialInformationReports?: QuickbooksReportAC[] | undefined;
    financialStatementId: string;
    loanApplicationId: string;
    entityFinanceYearlyMappings?: EntityFinanceYearlyMappingAC[] | undefined;
    loanApplicationNumber?: string | undefined;
    reportName?: string | undefined;
    quickbooksTokens?: QuickbooksTokenAC | undefined;
    isCallFromRedirect: boolean;
    financialStatement?: string | undefined;
    userId: string;
    financialInformationJson?: string | undefined;
    accessToken?: string | undefined;
    namedReportType: NamedReportType;
    fromDate?: Date | undefined;
    toDate?: Date | undefined;
    lastYears: number;
    financialInformationFrom?: FinancialInformationFrom | undefined;
    financialAccountTypeACs?: FinancialAccountTypeAC[] | undefined;
    isEmptyReport: boolean;
}

export class QuickbooksReportAC implements IQuickbooksReportAC {
    quickbooksReport?: Report | undefined;
    reportName?: string | undefined;

    constructor(data?: IQuickbooksReportAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.quickbooksReport = _data["quickbooksReport"] ? Report.fromJS(_data["quickbooksReport"]) : <any>undefined;
            this.reportName = _data["reportName"];
        }
    }

    static fromJS(data: any): QuickbooksReportAC {
        data = typeof data === 'object' ? data : {};
        let result = new QuickbooksReportAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["quickbooksReport"] = this.quickbooksReport ? this.quickbooksReport.toJSON() : <any>undefined;
        data["reportName"] = this.reportName;
        return data; 
    }
}

export interface IQuickbooksReportAC {
    quickbooksReport?: Report | undefined;
    reportName?: string | undefined;
}

export class Report implements IReport {
    header?: ReportHeader | undefined;
    columns?: Column[] | undefined;
    rows?: Row[] | undefined;

    constructor(data?: IReport) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.header = _data["header"] ? ReportHeader.fromJS(_data["header"]) : <any>undefined;
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(Column.fromJS(item));
            }
            if (Array.isArray(_data["rows"])) {
                this.rows = [] as any;
                for (let item of _data["rows"])
                    this.rows!.push(Row.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Report {
        data = typeof data === 'object' ? data : {};
        let result = new Report();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["header"] = this.header ? this.header.toJSON() : <any>undefined;
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        if (Array.isArray(this.rows)) {
            data["rows"] = [];
            for (let item of this.rows)
                data["rows"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReport {
    header?: ReportHeader | undefined;
    columns?: Column[] | undefined;
    rows?: Row[] | undefined;
}

export class ReportHeader implements IReportHeader {
    time!: Date;
    reportName?: string | undefined;
    dateMacro?: string | undefined;
    reportBasis!: ReportBasisEnum;
    startPeriod?: string | undefined;
    endPeriod?: string | undefined;
    summarizeColumnsBy?: string | undefined;
    currency?: string | undefined;
    customer?: string | undefined;
    vendor?: string | undefined;
    employee?: string | undefined;
    anyIntuitObject?: string | undefined;
    class?: string | undefined;
    department?: string | undefined;
    option?: NameValue[] | undefined;

    constructor(data?: IReportHeader) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"] ? new Date(_data["time"].toString()) : <any>undefined;
            this.reportName = _data["reportName"];
            this.dateMacro = _data["dateMacro"];
            this.reportBasis = _data["reportBasis"];
            this.startPeriod = _data["startPeriod"];
            this.endPeriod = _data["endPeriod"];
            this.summarizeColumnsBy = _data["summarizeColumnsBy"];
            this.currency = _data["currency"];
            this.customer = _data["customer"];
            this.vendor = _data["vendor"];
            this.employee = _data["employee"];
            this.anyIntuitObject = _data["anyIntuitObject"];
            this.class = _data["class"];
            this.department = _data["department"];
            if (Array.isArray(_data["option"])) {
                this.option = [] as any;
                for (let item of _data["option"])
                    this.option!.push(NameValue.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ReportHeader {
        data = typeof data === 'object' ? data : {};
        let result = new ReportHeader();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time ? this.time.toISOString() : <any>undefined;
        data["reportName"] = this.reportName;
        data["dateMacro"] = this.dateMacro;
        data["reportBasis"] = this.reportBasis;
        data["startPeriod"] = this.startPeriod;
        data["endPeriod"] = this.endPeriod;
        data["summarizeColumnsBy"] = this.summarizeColumnsBy;
        data["currency"] = this.currency;
        data["customer"] = this.customer;
        data["vendor"] = this.vendor;
        data["employee"] = this.employee;
        data["anyIntuitObject"] = this.anyIntuitObject;
        data["class"] = this.class;
        data["department"] = this.department;
        if (Array.isArray(this.option)) {
            data["option"] = [];
            for (let item of this.option)
                data["option"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IReportHeader {
    time: Date;
    reportName?: string | undefined;
    dateMacro?: string | undefined;
    reportBasis: ReportBasisEnum;
    startPeriod?: string | undefined;
    endPeriod?: string | undefined;
    summarizeColumnsBy?: string | undefined;
    currency?: string | undefined;
    customer?: string | undefined;
    vendor?: string | undefined;
    employee?: string | undefined;
    anyIntuitObject?: string | undefined;
    class?: string | undefined;
    department?: string | undefined;
    option?: NameValue[] | undefined;
}

export enum ReportBasisEnum {
    Accrual = 0,
    Cash = 1,
}

export class NameValue implements INameValue {
    name?: string | undefined;
    value?: string | undefined;

    constructor(data?: INameValue) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): NameValue {
        data = typeof data === 'object' ? data : {};
        let result = new NameValue();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["value"] = this.value;
        return data; 
    }
}

export interface INameValue {
    name?: string | undefined;
    value?: string | undefined;
}

export class Column implements IColumn {
    colTitle?: string | undefined;
    colType?: string | undefined;
    metaData?: NameValue[] | undefined;
    columns?: Column[] | undefined;

    constructor(data?: IColumn) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.colTitle = _data["colTitle"];
            this.colType = _data["colType"];
            if (Array.isArray(_data["metaData"])) {
                this.metaData = [] as any;
                for (let item of _data["metaData"])
                    this.metaData!.push(NameValue.fromJS(item));
            }
            if (Array.isArray(_data["columns"])) {
                this.columns = [] as any;
                for (let item of _data["columns"])
                    this.columns!.push(Column.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Column {
        data = typeof data === 'object' ? data : {};
        let result = new Column();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["colTitle"] = this.colTitle;
        data["colType"] = this.colType;
        if (Array.isArray(this.metaData)) {
            data["metaData"] = [];
            for (let item of this.metaData)
                data["metaData"].push(item.toJSON());
        }
        if (Array.isArray(this.columns)) {
            data["columns"] = [];
            for (let item of this.columns)
                data["columns"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IColumn {
    colTitle?: string | undefined;
    colType?: string | undefined;
    metaData?: NameValue[] | undefined;
    columns?: Column[] | undefined;
}

export class Row implements IRow {
    id?: string | undefined;
    parentId?: string | undefined;
    anyIntuitObjects?: any[] | undefined;
    type!: RowTypeEnum;
    group?: string | undefined;

    constructor(data?: IRow) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parentId = _data["parentId"];
            if (Array.isArray(_data["anyIntuitObjects"])) {
                this.anyIntuitObjects = [] as any;
                for (let item of _data["anyIntuitObjects"])
                    this.anyIntuitObjects!.push(item);
            }
            this.type = _data["type"];
            this.group = _data["group"];
        }
    }

    static fromJS(data: any): Row {
        data = typeof data === 'object' ? data : {};
        let result = new Row();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parentId"] = this.parentId;
        if (Array.isArray(this.anyIntuitObjects)) {
            data["anyIntuitObjects"] = [];
            for (let item of this.anyIntuitObjects)
                data["anyIntuitObjects"].push(item);
        }
        data["type"] = this.type;
        data["group"] = this.group;
        return data; 
    }
}

export interface IRow {
    id?: string | undefined;
    parentId?: string | undefined;
    anyIntuitObjects?: any[] | undefined;
    type: RowTypeEnum;
    group?: string | undefined;
}

export enum RowTypeEnum {
    Section = 0,
    Data = 1,
}

export class EntityFinanceYearlyMappingAC implements IEntityFinanceYearlyMappingAC {
    id!: string;
    period?: string | undefined;
    entityFinanceId!: string;
    uploadedDocumentId?: string | undefined;
    uploadedDocumentPath?: string | undefined;
    documentName?: string | undefined;
    documentPathToDownload?: string | undefined;
    entityFinanceStandardAccounts?: EntityFinanceStandardAccountsAC[] | undefined;

    constructor(data?: IEntityFinanceYearlyMappingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.period = _data["period"];
            this.entityFinanceId = _data["entityFinanceId"];
            this.uploadedDocumentId = _data["uploadedDocumentId"];
            this.uploadedDocumentPath = _data["uploadedDocumentPath"];
            this.documentName = _data["documentName"];
            this.documentPathToDownload = _data["documentPathToDownload"];
            if (Array.isArray(_data["entityFinanceStandardAccounts"])) {
                this.entityFinanceStandardAccounts = [] as any;
                for (let item of _data["entityFinanceStandardAccounts"])
                    this.entityFinanceStandardAccounts!.push(EntityFinanceStandardAccountsAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityFinanceYearlyMappingAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFinanceYearlyMappingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["period"] = this.period;
        data["entityFinanceId"] = this.entityFinanceId;
        data["uploadedDocumentId"] = this.uploadedDocumentId;
        data["uploadedDocumentPath"] = this.uploadedDocumentPath;
        data["documentName"] = this.documentName;
        data["documentPathToDownload"] = this.documentPathToDownload;
        if (Array.isArray(this.entityFinanceStandardAccounts)) {
            data["entityFinanceStandardAccounts"] = [];
            for (let item of this.entityFinanceStandardAccounts)
                data["entityFinanceStandardAccounts"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEntityFinanceYearlyMappingAC {
    id: string;
    period?: string | undefined;
    entityFinanceId: string;
    uploadedDocumentId?: string | undefined;
    uploadedDocumentPath?: string | undefined;
    documentName?: string | undefined;
    documentPathToDownload?: string | undefined;
    entityFinanceStandardAccounts?: EntityFinanceStandardAccountsAC[] | undefined;
}

export class EntityFinanceStandardAccountsAC implements IEntityFinanceStandardAccountsAC {
    id!: string;
    financialAccountTypeId!: string;
    amount?: number | undefined;
    entityFinancialManualInformations?: EntityFinancialManualInformationAC[] | undefined;
    entityFinancialYearlyMappingId!: string;
    financialAccountType?: string | undefined;

    constructor(data?: IEntityFinanceStandardAccountsAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.financialAccountTypeId = _data["financialAccountTypeId"];
            this.amount = _data["amount"];
            if (Array.isArray(_data["entityFinancialManualInformations"])) {
                this.entityFinancialManualInformations = [] as any;
                for (let item of _data["entityFinancialManualInformations"])
                    this.entityFinancialManualInformations!.push(EntityFinancialManualInformationAC.fromJS(item));
            }
            this.entityFinancialYearlyMappingId = _data["entityFinancialYearlyMappingId"];
            this.financialAccountType = _data["financialAccountType"];
        }
    }

    static fromJS(data: any): EntityFinanceStandardAccountsAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFinanceStandardAccountsAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["financialAccountTypeId"] = this.financialAccountTypeId;
        data["amount"] = this.amount;
        if (Array.isArray(this.entityFinancialManualInformations)) {
            data["entityFinancialManualInformations"] = [];
            for (let item of this.entityFinancialManualInformations)
                data["entityFinancialManualInformations"].push(item.toJSON());
        }
        data["entityFinancialYearlyMappingId"] = this.entityFinancialYearlyMappingId;
        data["financialAccountType"] = this.financialAccountType;
        return data; 
    }
}

export interface IEntityFinanceStandardAccountsAC {
    id: string;
    financialAccountTypeId: string;
    amount?: number | undefined;
    entityFinancialManualInformations?: EntityFinancialManualInformationAC[] | undefined;
    entityFinancialYearlyMappingId: string;
    financialAccountType?: string | undefined;
}

export class EntityFinancialManualInformationAC implements IEntityFinancialManualInformationAC {
    id!: string;
    subAccountName?: string | undefined;
    amount?: number | undefined;
    entityFinancialManualInformations?: EntityFinancialManualInformationAC[] | undefined;

    constructor(data?: IEntityFinancialManualInformationAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subAccountName = _data["subAccountName"];
            this.amount = _data["amount"];
            if (Array.isArray(_data["entityFinancialManualInformations"])) {
                this.entityFinancialManualInformations = [] as any;
                for (let item of _data["entityFinancialManualInformations"])
                    this.entityFinancialManualInformations!.push(EntityFinancialManualInformationAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): EntityFinancialManualInformationAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityFinancialManualInformationAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subAccountName"] = this.subAccountName;
        data["amount"] = this.amount;
        if (Array.isArray(this.entityFinancialManualInformations)) {
            data["entityFinancialManualInformations"] = [];
            for (let item of this.entityFinancialManualInformations)
                data["entityFinancialManualInformations"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IEntityFinancialManualInformationAC {
    id: string;
    subAccountName?: string | undefined;
    amount?: number | undefined;
    entityFinancialManualInformations?: EntityFinancialManualInformationAC[] | undefined;
}

export class QuickbooksTokenAC implements IQuickbooksTokenAC {
    realmId?: string | undefined;
    authorizationCode?: string | undefined;
    refreshToken?: string | undefined;
    bearerToken?: string | undefined;
    isError!: boolean;
    errorMessage?: string | undefined;
    csrfToken!: string;
    loanApplicationId!: string;

    constructor(data?: IQuickbooksTokenAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.realmId = _data["realmId"];
            this.authorizationCode = _data["authorizationCode"];
            this.refreshToken = _data["refreshToken"];
            this.bearerToken = _data["bearerToken"];
            this.isError = _data["isError"];
            this.errorMessage = _data["errorMessage"];
            this.csrfToken = _data["csrfToken"];
            this.loanApplicationId = _data["loanApplicationId"];
        }
    }

    static fromJS(data: any): QuickbooksTokenAC {
        data = typeof data === 'object' ? data : {};
        let result = new QuickbooksTokenAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["realmId"] = this.realmId;
        data["authorizationCode"] = this.authorizationCode;
        data["refreshToken"] = this.refreshToken;
        data["bearerToken"] = this.bearerToken;
        data["isError"] = this.isError;
        data["errorMessage"] = this.errorMessage;
        data["csrfToken"] = this.csrfToken;
        data["loanApplicationId"] = this.loanApplicationId;
        return data; 
    }
}

export interface IQuickbooksTokenAC {
    realmId?: string | undefined;
    authorizationCode?: string | undefined;
    refreshToken?: string | undefined;
    bearerToken?: string | undefined;
    isError: boolean;
    errorMessage?: string | undefined;
    csrfToken: string;
    loanApplicationId: string;
}

export enum NamedReportType {
    BalanceSheet = 0,
    ProfitAndLoss = 1,
}

export enum FinancialInformationFrom {
    Manual = 0,
    Quickbooks = 1,
    Xero = 2,
    PayPal = 3,
    Square = 4,
    Stripe = 5,
}

export class FinancialAccountTypeAC implements IFinancialAccountTypeAC {
    id!: string;
    name?: string | undefined;
    financialStatementId!: string;

    constructor(data?: IFinancialAccountTypeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.financialStatementId = _data["financialStatementId"];
        }
    }

    static fromJS(data: any): FinancialAccountTypeAC {
        data = typeof data === 'object' ? data : {};
        let result = new FinancialAccountTypeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["financialStatementId"] = this.financialStatementId;
        return data; 
    }
}

export interface IFinancialAccountTypeAC {
    id: string;
    name?: string | undefined;
    financialStatementId: string;
}

export class LoanProductListAC implements ILoanProductListAC {
    loanProductList?: LoanProductAC[] | undefined;

    constructor(data?: ILoanProductListAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["loanProductList"])) {
                this.loanProductList = [] as any;
                for (let item of _data["loanProductList"])
                    this.loanProductList!.push(LoanProductAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoanProductListAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanProductListAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.loanProductList)) {
            data["loanProductList"] = [];
            for (let item of this.loanProductList)
                data["loanProductList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILoanProductListAC {
    loanProductList?: LoanProductAC[] | undefined;
}

export class LoanProductAC implements ILoanProductAC {
    id!: string;
    name!: string;
    description!: string;
    productStartDate!: Date;
    productEndDate!: Date;
    interestRateType!: string;
    fixedRate?: number | undefined;
    baseVariableRate?: number | undefined;
    marginVariableRate?: number | undefined;
    annualPercentageRate?: number | undefined;
    maxAmount?: string | undefined;
    periodRange?: string | undefined;
    isRecommended!: boolean;
    interestOnlyPeriodRange?: string | undefined;
    fixedRatePeriodRange?: string | undefined;
    isExtraPaymentWithdrawnAllowed!: boolean;
    currencySymbol?: string | undefined;
    loanProductDetailAC?: LoanProductDetailAC | undefined;
    loanFeeTypeListAC?: LoanFeeTypeListAC | undefined;
    loanApplicationAC?: LoanApplicationAC | undefined;

    constructor(data?: ILoanProductAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.productStartDate = _data["productStartDate"] ? new Date(_data["productStartDate"].toString()) : <any>undefined;
            this.productEndDate = _data["productEndDate"] ? new Date(_data["productEndDate"].toString()) : <any>undefined;
            this.interestRateType = _data["interestRateType"];
            this.fixedRate = _data["fixedRate"];
            this.baseVariableRate = _data["baseVariableRate"];
            this.marginVariableRate = _data["marginVariableRate"];
            this.annualPercentageRate = _data["annualPercentageRate"];
            this.maxAmount = _data["maxAmount"];
            this.periodRange = _data["periodRange"];
            this.isRecommended = _data["isRecommended"];
            this.interestOnlyPeriodRange = _data["interestOnlyPeriodRange"];
            this.fixedRatePeriodRange = _data["fixedRatePeriodRange"];
            this.isExtraPaymentWithdrawnAllowed = _data["isExtraPaymentWithdrawnAllowed"];
            this.currencySymbol = _data["currencySymbol"];
            this.loanProductDetailAC = _data["loanProductDetailAC"] ? LoanProductDetailAC.fromJS(_data["loanProductDetailAC"]) : <any>undefined;
            this.loanFeeTypeListAC = _data["loanFeeTypeListAC"] ? LoanFeeTypeListAC.fromJS(_data["loanFeeTypeListAC"]) : <any>undefined;
            this.loanApplicationAC = _data["loanApplicationAC"] ? LoanApplicationAC.fromJS(_data["loanApplicationAC"]) : <any>undefined;
        }
    }

    static fromJS(data: any): LoanProductAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanProductAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["productStartDate"] = this.productStartDate ? this.productStartDate.toISOString() : <any>undefined;
        data["productEndDate"] = this.productEndDate ? this.productEndDate.toISOString() : <any>undefined;
        data["interestRateType"] = this.interestRateType;
        data["fixedRate"] = this.fixedRate;
        data["baseVariableRate"] = this.baseVariableRate;
        data["marginVariableRate"] = this.marginVariableRate;
        data["annualPercentageRate"] = this.annualPercentageRate;
        data["maxAmount"] = this.maxAmount;
        data["periodRange"] = this.periodRange;
        data["isRecommended"] = this.isRecommended;
        data["interestOnlyPeriodRange"] = this.interestOnlyPeriodRange;
        data["fixedRatePeriodRange"] = this.fixedRatePeriodRange;
        data["isExtraPaymentWithdrawnAllowed"] = this.isExtraPaymentWithdrawnAllowed;
        data["currencySymbol"] = this.currencySymbol;
        data["loanProductDetailAC"] = this.loanProductDetailAC ? this.loanProductDetailAC.toJSON() : <any>undefined;
        data["loanFeeTypeListAC"] = this.loanFeeTypeListAC ? this.loanFeeTypeListAC.toJSON() : <any>undefined;
        data["loanApplicationAC"] = this.loanApplicationAC ? this.loanApplicationAC.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ILoanProductAC {
    id: string;
    name: string;
    description: string;
    productStartDate: Date;
    productEndDate: Date;
    interestRateType: string;
    fixedRate?: number | undefined;
    baseVariableRate?: number | undefined;
    marginVariableRate?: number | undefined;
    annualPercentageRate?: number | undefined;
    maxAmount?: string | undefined;
    periodRange?: string | undefined;
    isRecommended: boolean;
    interestOnlyPeriodRange?: string | undefined;
    fixedRatePeriodRange?: string | undefined;
    isExtraPaymentWithdrawnAllowed: boolean;
    currencySymbol?: string | undefined;
    loanProductDetailAC?: LoanProductDetailAC | undefined;
    loanFeeTypeListAC?: LoanFeeTypeListAC | undefined;
    loanApplicationAC?: LoanApplicationAC | undefined;
}

export class LoanProductDetailAC implements ILoanProductDetailAC {
    loanAmount!: number;
    period!: number;
    minProductPeriod!: number;
    maxProductPeriod!: number;
    monthlyPayment!: number;
    minMonthlyPayment!: number;
    maxMonthlyPayment!: number;
    totalPayment?: string | undefined;
    totalInterest?: string | undefined;

    constructor(data?: ILoanProductDetailAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanAmount = _data["loanAmount"];
            this.period = _data["period"];
            this.minProductPeriod = _data["minProductPeriod"];
            this.maxProductPeriod = _data["maxProductPeriod"];
            this.monthlyPayment = _data["monthlyPayment"];
            this.minMonthlyPayment = _data["minMonthlyPayment"];
            this.maxMonthlyPayment = _data["maxMonthlyPayment"];
            this.totalPayment = _data["totalPayment"];
            this.totalInterest = _data["totalInterest"];
        }
    }

    static fromJS(data: any): LoanProductDetailAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanProductDetailAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanAmount"] = this.loanAmount;
        data["period"] = this.period;
        data["minProductPeriod"] = this.minProductPeriod;
        data["maxProductPeriod"] = this.maxProductPeriod;
        data["monthlyPayment"] = this.monthlyPayment;
        data["minMonthlyPayment"] = this.minMonthlyPayment;
        data["maxMonthlyPayment"] = this.maxMonthlyPayment;
        data["totalPayment"] = this.totalPayment;
        data["totalInterest"] = this.totalInterest;
        return data; 
    }
}

export interface ILoanProductDetailAC {
    loanAmount: number;
    period: number;
    minProductPeriod: number;
    maxProductPeriod: number;
    monthlyPayment: number;
    minMonthlyPayment: number;
    maxMonthlyPayment: number;
    totalPayment?: string | undefined;
    totalInterest?: string | undefined;
}

export class LoanFeeTypeListAC implements ILoanFeeTypeListAC {
    loanFeeTypeDetailACs?: LoanFeeTypeDetailAC[] | undefined;

    constructor(data?: ILoanFeeTypeListAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["loanFeeTypeDetailACs"])) {
                this.loanFeeTypeDetailACs = [] as any;
                for (let item of _data["loanFeeTypeDetailACs"])
                    this.loanFeeTypeDetailACs!.push(LoanFeeTypeDetailAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): LoanFeeTypeListAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanFeeTypeListAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.loanFeeTypeDetailACs)) {
            data["loanFeeTypeDetailACs"] = [];
            for (let item of this.loanFeeTypeDetailACs)
                data["loanFeeTypeDetailACs"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ILoanFeeTypeListAC {
    loanFeeTypeDetailACs?: LoanFeeTypeDetailAC[] | undefined;
}

export class LoanFeeTypeDetailAC implements ILoanFeeTypeDetailAC {
    id!: string;
    name!: string;
    description!: string;
    amount?: string | undefined;
    percentage?: string | undefined;
    frequencyType?: string | undefined;

    constructor(data?: ILoanFeeTypeDetailAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.percentage = _data["percentage"];
            this.frequencyType = _data["frequencyType"];
        }
    }

    static fromJS(data: any): LoanFeeTypeDetailAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanFeeTypeDetailAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["percentage"] = this.percentage;
        data["frequencyType"] = this.frequencyType;
        return data; 
    }
}

export interface ILoanFeeTypeDetailAC {
    id: string;
    name: string;
    description: string;
    amount?: string | undefined;
    percentage?: string | undefined;
    frequencyType?: string | undefined;
}

export class LoanApplicationProductMappingAC implements ILoanApplicationProductMappingAC {
    id!: string;
    loanApplicationId!: string;
    loanProductId!: string;

    constructor(data?: ILoanApplicationProductMappingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.loanApplicationId = _data["loanApplicationId"];
            this.loanProductId = _data["loanProductId"];
        }
    }

    static fromJS(data: any): LoanApplicationProductMappingAC {
        data = typeof data === 'object' ? data : {};
        let result = new LoanApplicationProductMappingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["loanApplicationId"] = this.loanApplicationId;
        data["loanProductId"] = this.loanProductId;
        return data; 
    }
}

export interface ILoanApplicationProductMappingAC {
    id: string;
    loanApplicationId: string;
    loanProductId: string;
}

export class ConsentAC implements IConsentAC {
    id!: string;
    consentText!: string;
    isConsentGiven!: boolean;

    constructor(data?: IConsentAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.consentText = _data["consentText"];
            this.isConsentGiven = _data["isConsentGiven"];
        }
    }

    static fromJS(data: any): ConsentAC {
        data = typeof data === 'object' ? data : {};
        let result = new ConsentAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["consentText"] = this.consentText;
        data["isConsentGiven"] = this.isConsentGiven;
        return data; 
    }
}

export interface IConsentAC {
    id: string;
    consentText: string;
    isConsentGiven: boolean;
}

export class EntityLoanApplicationConsentAC implements IEntityLoanApplicationConsentAC {
    id!: string;
    userId!: string;
    user?: UserAC | undefined;
    loanApplicationId!: string;
    isConsentGiven!: boolean;

    constructor(data?: IEntityLoanApplicationConsentAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? UserAC.fromJS(_data["user"]) : <any>undefined;
            this.loanApplicationId = _data["loanApplicationId"];
            this.isConsentGiven = _data["isConsentGiven"];
        }
    }

    static fromJS(data: any): EntityLoanApplicationConsentAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityLoanApplicationConsentAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["loanApplicationId"] = this.loanApplicationId;
        data["isConsentGiven"] = this.isConsentGiven;
        return data; 
    }
}

export interface IEntityLoanApplicationConsentAC {
    id: string;
    userId: string;
    user?: UserAC | undefined;
    loanApplicationId: string;
    isConsentGiven: boolean;
}

export class UserAC implements IUserAC {
    id!: string;
    name!: string;
    email!: string;
    ssn?: string | undefined;
    phone!: string;
    sharePercentage?: number | undefined;
    relationship?: string | undefined;
    dob?: Date | undefined;

    constructor(data?: IUserAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.email = _data["email"];
            this.ssn = _data["ssn"];
            this.phone = _data["phone"];
            this.sharePercentage = _data["sharePercentage"];
            this.relationship = _data["relationship"];
            this.dob = _data["dob"] ? new Date(_data["dob"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserAC {
        data = typeof data === 'object' ? data : {};
        let result = new UserAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["email"] = this.email;
        data["ssn"] = this.ssn;
        data["phone"] = this.phone;
        data["sharePercentage"] = this.sharePercentage;
        data["relationship"] = this.relationship;
        data["dob"] = this.dob ? this.dob.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserAC {
    id: string;
    name: string;
    email: string;
    ssn?: string | undefined;
    phone: string;
    sharePercentage?: number | undefined;
    relationship?: string | undefined;
    dob?: Date | undefined;
}

export class BankAC implements IBankAC {
    id!: string;
    name?: string | undefined;
    swiftCode?: string | undefined;

    constructor(data?: IBankAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.swiftCode = _data["swiftCode"];
        }
    }

    static fromJS(data: any): BankAC {
        data = typeof data === 'object' ? data : {};
        let result = new BankAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["swiftCode"] = this.swiftCode;
        return data; 
    }
}

export interface IBankAC {
    id: string;
    name?: string | undefined;
    swiftCode?: string | undefined;
}

export class CompanyAC implements ICompanyAC {
    id!: string;
    name!: string;
    cin?: string | undefined;
    companyTypeId!: string;
    sicCode!: string;
    businessAgeId!: string;
    employeeStrengthId!: string;
    employeeStrength?: string | undefined;
    businessAge?: string | undefined;
    companyType?: string | undefined;
    industryTitle?: string | undefined;
    address?: AddressAC | undefined;

    constructor(data?: ICompanyAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cin = _data["cin"];
            this.companyTypeId = _data["companyTypeId"];
            this.sicCode = _data["sicCode"];
            this.businessAgeId = _data["businessAgeId"];
            this.employeeStrengthId = _data["employeeStrengthId"];
            this.employeeStrength = _data["employeeStrength"];
            this.businessAge = _data["businessAge"];
            this.companyType = _data["companyType"];
            this.industryTitle = _data["industryTitle"];
            this.address = _data["address"] ? AddressAC.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CompanyAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cin"] = this.cin;
        data["companyTypeId"] = this.companyTypeId;
        data["sicCode"] = this.sicCode;
        data["businessAgeId"] = this.businessAgeId;
        data["employeeStrengthId"] = this.employeeStrengthId;
        data["employeeStrength"] = this.employeeStrength;
        data["businessAge"] = this.businessAge;
        data["companyType"] = this.companyType;
        data["industryTitle"] = this.industryTitle;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface ICompanyAC {
    id: string;
    name: string;
    cin?: string | undefined;
    companyTypeId: string;
    sicCode: string;
    businessAgeId: string;
    employeeStrengthId: string;
    employeeStrength?: string | undefined;
    businessAge?: string | undefined;
    companyType?: string | undefined;
    industryTitle?: string | undefined;
    address?: AddressAC | undefined;
}

export class AddressAC implements IAddressAC {
    id!: string;
    primaryNumber?: string | undefined;
    streetLine!: string;
    city!: string;
    stateAbbreviation!: string;
    streetSuffix?: string | undefined;
    secondaryNumber?: string | undefined;
    secondaryDesignator?: string | undefined;
    zipCode?: string | undefined;
    response?: string | undefined;
    responseSource?: string | undefined;

    constructor(data?: IAddressAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.primaryNumber = _data["primaryNumber"];
            this.streetLine = _data["streetLine"];
            this.city = _data["city"];
            this.stateAbbreviation = _data["stateAbbreviation"];
            this.streetSuffix = _data["streetSuffix"];
            this.secondaryNumber = _data["secondaryNumber"];
            this.secondaryDesignator = _data["secondaryDesignator"];
            this.zipCode = _data["zipCode"];
            this.response = _data["response"];
            this.responseSource = _data["responseSource"];
        }
    }

    static fromJS(data: any): AddressAC {
        data = typeof data === 'object' ? data : {};
        let result = new AddressAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["primaryNumber"] = this.primaryNumber;
        data["streetLine"] = this.streetLine;
        data["city"] = this.city;
        data["stateAbbreviation"] = this.stateAbbreviation;
        data["streetSuffix"] = this.streetSuffix;
        data["secondaryNumber"] = this.secondaryNumber;
        data["secondaryDesignator"] = this.secondaryDesignator;
        data["zipCode"] = this.zipCode;
        data["response"] = this.response;
        data["responseSource"] = this.responseSource;
        return data; 
    }
}

export interface IAddressAC {
    id: string;
    primaryNumber?: string | undefined;
    streetLine: string;
    city: string;
    stateAbbreviation: string;
    streetSuffix?: string | undefined;
    secondaryNumber?: string | undefined;
    secondaryDesignator?: string | undefined;
    zipCode?: string | undefined;
    response?: string | undefined;
    responseSource?: string | undefined;
}

export class CompanyInfoOptionAC implements ICompanyInfoOptionAC {
    companyTypeList!: CompanyTypeAC[];
    businessAgeList!: BusinessAgeAC[];
    employeeStrengthList!: EmployeeStrengthAC[];

    constructor(data?: ICompanyInfoOptionAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.companyTypeList = [];
            this.businessAgeList = [];
            this.employeeStrengthList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["companyTypeList"])) {
                this.companyTypeList = [] as any;
                for (let item of _data["companyTypeList"])
                    this.companyTypeList!.push(CompanyTypeAC.fromJS(item));
            }
            if (Array.isArray(_data["businessAgeList"])) {
                this.businessAgeList = [] as any;
                for (let item of _data["businessAgeList"])
                    this.businessAgeList!.push(BusinessAgeAC.fromJS(item));
            }
            if (Array.isArray(_data["employeeStrengthList"])) {
                this.employeeStrengthList = [] as any;
                for (let item of _data["employeeStrengthList"])
                    this.employeeStrengthList!.push(EmployeeStrengthAC.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CompanyInfoOptionAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyInfoOptionAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.companyTypeList)) {
            data["companyTypeList"] = [];
            for (let item of this.companyTypeList)
                data["companyTypeList"].push(item.toJSON());
        }
        if (Array.isArray(this.businessAgeList)) {
            data["businessAgeList"] = [];
            for (let item of this.businessAgeList)
                data["businessAgeList"].push(item.toJSON());
        }
        if (Array.isArray(this.employeeStrengthList)) {
            data["employeeStrengthList"] = [];
            for (let item of this.employeeStrengthList)
                data["employeeStrengthList"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICompanyInfoOptionAC {
    companyTypeList: CompanyTypeAC[];
    businessAgeList: BusinessAgeAC[];
    employeeStrengthList: EmployeeStrengthAC[];
}

export class CompanyTypeAC implements ICompanyTypeAC {
    id!: string;
    name!: string;
    order!: number;

    constructor(data?: ICompanyTypeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CompanyTypeAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyTypeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICompanyTypeAC {
    id: string;
    name: string;
    order: number;
}

export class BusinessAgeAC implements IBusinessAgeAC {
    id!: string;
    age!: string;
    order!: number;

    constructor(data?: IBusinessAgeAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.age = _data["age"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): BusinessAgeAC {
        data = typeof data === 'object' ? data : {};
        let result = new BusinessAgeAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["age"] = this.age;
        data["order"] = this.order;
        return data; 
    }
}

export interface IBusinessAgeAC {
    id: string;
    age: string;
    order: number;
}

export class EmployeeStrengthAC implements IEmployeeStrengthAC {
    id!: string;
    strength!: string;
    order!: number;

    constructor(data?: IEmployeeStrengthAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.strength = _data["strength"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): EmployeeStrengthAC {
        data = typeof data === 'object' ? data : {};
        let result = new EmployeeStrengthAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["strength"] = this.strength;
        data["order"] = this.order;
        return data; 
    }
}

export interface IEmployeeStrengthAC {
    id: string;
    strength: string;
    order: number;
}

export class CompanyInfoAC implements ICompanyInfoAC {
    id?: string | undefined;
    name!: string;
    cin?: string | undefined;
    companyTypeId!: string;
    sicCode!: string;
    businessAgeId!: string;
    employeeStrengthId!: string;
    shareHolderUsers!: UserAC[];
    address!: AddressAC;
    loanApplicationId!: string;

    constructor(data?: ICompanyInfoAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.shareHolderUsers = [];
            this.address = new AddressAC();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.cin = _data["cin"];
            this.companyTypeId = _data["companyTypeId"];
            this.sicCode = _data["sicCode"];
            this.businessAgeId = _data["businessAgeId"];
            this.employeeStrengthId = _data["employeeStrengthId"];
            if (Array.isArray(_data["shareHolderUsers"])) {
                this.shareHolderUsers = [] as any;
                for (let item of _data["shareHolderUsers"])
                    this.shareHolderUsers!.push(UserAC.fromJS(item));
            }
            this.address = _data["address"] ? AddressAC.fromJS(_data["address"]) : new AddressAC();
            this.loanApplicationId = _data["loanApplicationId"];
        }
    }

    static fromJS(data: any): CompanyInfoAC {
        data = typeof data === 'object' ? data : {};
        let result = new CompanyInfoAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["cin"] = this.cin;
        data["companyTypeId"] = this.companyTypeId;
        data["sicCode"] = this.sicCode;
        data["businessAgeId"] = this.businessAgeId;
        data["employeeStrengthId"] = this.employeeStrengthId;
        if (Array.isArray(this.shareHolderUsers)) {
            data["shareHolderUsers"] = [];
            for (let item of this.shareHolderUsers)
                data["shareHolderUsers"].push(item.toJSON());
        }
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        data["loanApplicationId"] = this.loanApplicationId;
        return data; 
    }
}

export interface ICompanyInfoAC {
    id?: string | undefined;
    name: string;
    cin?: string | undefined;
    companyTypeId: string;
    sicCode: string;
    businessAgeId: string;
    employeeStrengthId: string;
    shareHolderUsers: UserAC[];
    address: AddressAC;
    loanApplicationId: string;
}

export class AwsSettings implements IAwsSettings {
    baseUrl?: string | undefined;
    preSignedUrl?: string | undefined;

    constructor(data?: IAwsSettings) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.baseUrl = _data["baseUrl"];
            this.preSignedUrl = _data["preSignedUrl"];
        }
    }

    static fromJS(data: any): AwsSettings {
        data = typeof data === 'object' ? data : {};
        let result = new AwsSettings();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["baseUrl"] = this.baseUrl;
        data["preSignedUrl"] = this.preSignedUrl;
        return data; 
    }
}

export interface IAwsSettings {
    baseUrl?: string | undefined;
    preSignedUrl?: string | undefined;
}

export class InvoiceListAC implements IInvoiceListAC {
    totalCount!: number;
    startingYear?: string | undefined;
    endingYear?: string | undefined;
    invoices?: InvoiceAC[] | undefined;
    financialInformationFrom?: FinancialInformationFrom | undefined;

    constructor(data?: IInvoiceListAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalCount = _data["totalCount"];
            this.startingYear = _data["startingYear"];
            this.endingYear = _data["endingYear"];
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(InvoiceAC.fromJS(item));
            }
            this.financialInformationFrom = _data["financialInformationFrom"];
        }
    }

    static fromJS(data: any): InvoiceListAC {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceListAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalCount"] = this.totalCount;
        data["startingYear"] = this.startingYear;
        data["endingYear"] = this.endingYear;
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        data["financialInformationFrom"] = this.financialInformationFrom;
        return data; 
    }
}

export interface IInvoiceListAC {
    totalCount: number;
    startingYear?: string | undefined;
    endingYear?: string | undefined;
    invoices?: InvoiceAC[] | undefined;
    financialInformationFrom?: FinancialInformationFrom | undefined;
}

export class InvoiceAC implements IInvoiceAC {
    id?: string | undefined;
    status?: string | undefined;
    invoiceNumber?: string | undefined;
    invoiceDate?: string | undefined;
    invoiceCreateDateTime?: string | undefined;
    invoicerEmail?: string | undefined;
    recipientEmail?: string | undefined;
    currencyCode?: string | undefined;
    totalAmount?: string | undefined;

    constructor(data?: IInvoiceAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.status = _data["status"];
            this.invoiceNumber = _data["invoiceNumber"];
            this.invoiceDate = _data["invoiceDate"];
            this.invoiceCreateDateTime = _data["invoiceCreateDateTime"];
            this.invoicerEmail = _data["invoicerEmail"];
            this.recipientEmail = _data["recipientEmail"];
            this.currencyCode = _data["currencyCode"];
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): InvoiceAC {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["status"] = this.status;
        data["invoiceNumber"] = this.invoiceNumber;
        data["invoiceDate"] = this.invoiceDate;
        data["invoiceCreateDateTime"] = this.invoiceCreateDateTime;
        data["invoicerEmail"] = this.invoicerEmail;
        data["recipientEmail"] = this.recipientEmail;
        data["currencyCode"] = this.currencyCode;
        data["totalAmount"] = this.totalAmount;
        return data; 
    }
}

export interface IInvoiceAC {
    id?: string | undefined;
    status?: string | undefined;
    invoiceNumber?: string | undefined;
    invoiceDate?: string | undefined;
    invoiceCreateDateTime?: string | undefined;
    invoicerEmail?: string | undefined;
    recipientEmail?: string | undefined;
    currencyCode?: string | undefined;
    totalAmount?: string | undefined;
}

export class InvoiceRequestParametersAC implements IInvoiceRequestParametersAC {
    loanApplicationId!: string;
    authorizationCode?: string | undefined;
    state?: string | undefined;
    financialInformationFrom!: FinancialInformationFrom;

    constructor(data?: IInvoiceRequestParametersAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loanApplicationId = _data["loanApplicationId"];
            this.authorizationCode = _data["authorizationCode"];
            this.state = _data["state"];
            this.financialInformationFrom = _data["financialInformationFrom"];
        }
    }

    static fromJS(data: any): InvoiceRequestParametersAC {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceRequestParametersAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loanApplicationId"] = this.loanApplicationId;
        data["authorizationCode"] = this.authorizationCode;
        data["state"] = this.state;
        data["financialInformationFrom"] = this.financialInformationFrom;
        return data; 
    }
}

export interface IInvoiceRequestParametersAC {
    loanApplicationId: string;
    authorizationCode?: string | undefined;
    state?: string | undefined;
    financialInformationFrom: FinancialInformationFrom;
}

export class YodleeFastLinkAC implements IYodleeFastLinkAC {
    fastLinkUrl?: string | undefined;
    accessToken?: string | undefined;

    constructor(data?: IYodleeFastLinkAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fastLinkUrl = _data["fastLinkUrl"];
            this.accessToken = _data["accessToken"];
        }
    }

    static fromJS(data: any): YodleeFastLinkAC {
        data = typeof data === 'object' ? data : {};
        let result = new YodleeFastLinkAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fastLinkUrl"] = this.fastLinkUrl;
        data["accessToken"] = this.accessToken;
        return data; 
    }
}

export interface IYodleeFastLinkAC {
    fastLinkUrl?: string | undefined;
    accessToken?: string | undefined;
}

export class ProviderBankListAC implements IProviderBankListAC {
    providerBanks?: ProviderBankAC[] | undefined;
    startingYear?: string | undefined;
    endingYear?: string | undefined;
    defaultTransactionInformationFrom!: TransactionInformationFrom;

    constructor(data?: IProviderBankListAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["providerBanks"])) {
                this.providerBanks = [] as any;
                for (let item of _data["providerBanks"])
                    this.providerBanks!.push(ProviderBankAC.fromJS(item));
            }
            this.startingYear = _data["startingYear"];
            this.endingYear = _data["endingYear"];
            this.defaultTransactionInformationFrom = _data["defaultTransactionInformationFrom"];
        }
    }

    static fromJS(data: any): ProviderBankListAC {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderBankListAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.providerBanks)) {
            data["providerBanks"] = [];
            for (let item of this.providerBanks)
                data["providerBanks"].push(item.toJSON());
        }
        data["startingYear"] = this.startingYear;
        data["endingYear"] = this.endingYear;
        data["defaultTransactionInformationFrom"] = this.defaultTransactionInformationFrom;
        return data; 
    }
}

export interface IProviderBankListAC {
    providerBanks?: ProviderBankAC[] | undefined;
    startingYear?: string | undefined;
    endingYear?: string | undefined;
    defaultTransactionInformationFrom: TransactionInformationFrom;
}

export class ProviderBankAC implements IProviderBankAC {
    id!: string;
    bankId?: string | undefined;
    bankName?: string | undefined;
    bankAccountTransactions?: BankAccountTransactionAC[] | undefined;
    bankInformationJson?: string | undefined;
    transactionInformationFrom!: TransactionInformationFrom;
    createdOn!: Date;
    updatedOn?: Date | undefined;

    constructor(data?: IProviderBankAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.bankId = _data["bankId"];
            this.bankName = _data["bankName"];
            if (Array.isArray(_data["bankAccountTransactions"])) {
                this.bankAccountTransactions = [] as any;
                for (let item of _data["bankAccountTransactions"])
                    this.bankAccountTransactions!.push(BankAccountTransactionAC.fromJS(item));
            }
            this.bankInformationJson = _data["bankInformationJson"];
            this.transactionInformationFrom = _data["transactionInformationFrom"];
            this.createdOn = _data["createdOn"] ? new Date(_data["createdOn"].toString()) : <any>undefined;
            this.updatedOn = _data["updatedOn"] ? new Date(_data["updatedOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): ProviderBankAC {
        data = typeof data === 'object' ? data : {};
        let result = new ProviderBankAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["bankId"] = this.bankId;
        data["bankName"] = this.bankName;
        if (Array.isArray(this.bankAccountTransactions)) {
            data["bankAccountTransactions"] = [];
            for (let item of this.bankAccountTransactions)
                data["bankAccountTransactions"].push(item.toJSON());
        }
        data["bankInformationJson"] = this.bankInformationJson;
        data["transactionInformationFrom"] = this.transactionInformationFrom;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IProviderBankAC {
    id: string;
    bankId?: string | undefined;
    bankName?: string | undefined;
    bankAccountTransactions?: BankAccountTransactionAC[] | undefined;
    bankInformationJson?: string | undefined;
    transactionInformationFrom: TransactionInformationFrom;
    createdOn: Date;
    updatedOn?: Date | undefined;
}

export class BankAccountTransactionAC implements IBankAccountTransactionAC {
    id!: string;
    accountId?: string | undefined;
    accountName?: string | undefined;
    currentBalance!: number;
    accountType?: string | undefined;
    transactionACs?: TransactionAC[] | undefined;
    accountInformationJson?: string | undefined;
    transactionInformationJson?: string | undefined;

    constructor(data?: IBankAccountTransactionAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.accountId = _data["accountId"];
            this.accountName = _data["accountName"];
            this.currentBalance = _data["currentBalance"];
            this.accountType = _data["accountType"];
            if (Array.isArray(_data["transactionACs"])) {
                this.transactionACs = [] as any;
                for (let item of _data["transactionACs"])
                    this.transactionACs!.push(TransactionAC.fromJS(item));
            }
            this.accountInformationJson = _data["accountInformationJson"];
            this.transactionInformationJson = _data["transactionInformationJson"];
        }
    }

    static fromJS(data: any): BankAccountTransactionAC {
        data = typeof data === 'object' ? data : {};
        let result = new BankAccountTransactionAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["accountId"] = this.accountId;
        data["accountName"] = this.accountName;
        data["currentBalance"] = this.currentBalance;
        data["accountType"] = this.accountType;
        if (Array.isArray(this.transactionACs)) {
            data["transactionACs"] = [];
            for (let item of this.transactionACs)
                data["transactionACs"].push(item.toJSON());
        }
        data["accountInformationJson"] = this.accountInformationJson;
        data["transactionInformationJson"] = this.transactionInformationJson;
        return data; 
    }
}

export interface IBankAccountTransactionAC {
    id: string;
    accountId?: string | undefined;
    accountName?: string | undefined;
    currentBalance: number;
    accountType?: string | undefined;
    transactionACs?: TransactionAC[] | undefined;
    accountInformationJson?: string | undefined;
    transactionInformationJson?: string | undefined;
}

export class TransactionAC implements ITransactionAC {
    id?: string | undefined;
    type?: string | undefined;
    description?: TransactionDescriptionAC | undefined;
    amount?: TransactionAmountAC | undefined;
    transactionDate?: string | undefined;

    constructor(data?: ITransactionAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.description = _data["description"] ? TransactionDescriptionAC.fromJS(_data["description"]) : <any>undefined;
            this.amount = _data["amount"] ? TransactionAmountAC.fromJS(_data["amount"]) : <any>undefined;
            this.transactionDate = _data["transactionDate"];
        }
    }

    static fromJS(data: any): TransactionAC {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["description"] = this.description ? this.description.toJSON() : <any>undefined;
        data["amount"] = this.amount ? this.amount.toJSON() : <any>undefined;
        data["transactionDate"] = this.transactionDate;
        return data; 
    }
}

export interface ITransactionAC {
    id?: string | undefined;
    type?: string | undefined;
    description?: TransactionDescriptionAC | undefined;
    amount?: TransactionAmountAC | undefined;
    transactionDate?: string | undefined;
}

export class TransactionDescriptionAC implements ITransactionDescriptionAC {
    original?: string | undefined;
    simple?: string | undefined;

    constructor(data?: ITransactionDescriptionAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.original = _data["original"];
            this.simple = _data["simple"];
        }
    }

    static fromJS(data: any): TransactionDescriptionAC {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionDescriptionAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["original"] = this.original;
        data["simple"] = this.simple;
        return data; 
    }
}

export interface ITransactionDescriptionAC {
    original?: string | undefined;
    simple?: string | undefined;
}

export class TransactionAmountAC implements ITransactionAmountAC {
    amount!: number;
    currency?: string | undefined;

    constructor(data?: ITransactionAmountAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.amount = _data["amount"];
            this.currency = _data["currency"];
        }
    }

    static fromJS(data: any): TransactionAmountAC {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionAmountAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["amount"] = this.amount;
        data["currency"] = this.currency;
        return data; 
    }
}

export interface ITransactionAmountAC {
    amount: number;
    currency?: string | undefined;
}

export enum TransactionInformationFrom {
    Yodlee = 0,
    Plaid = 1,
}

export class EntityBankAccountsMappingAC implements IEntityBankAccountsMappingAC {
    entityId!: string;
    loanApplicationId!: string;
    providerAccountIds?: number[] | undefined;
    isCleared!: boolean;
    publicToken?: string | undefined;

    constructor(data?: IEntityBankAccountsMappingAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.loanApplicationId = _data["loanApplicationId"];
            if (Array.isArray(_data["providerAccountIds"])) {
                this.providerAccountIds = [] as any;
                for (let item of _data["providerAccountIds"])
                    this.providerAccountIds!.push(item);
            }
            this.isCleared = _data["isCleared"];
            this.publicToken = _data["publicToken"];
        }
    }

    static fromJS(data: any): EntityBankAccountsMappingAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityBankAccountsMappingAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["loanApplicationId"] = this.loanApplicationId;
        if (Array.isArray(this.providerAccountIds)) {
            data["providerAccountIds"] = [];
            for (let item of this.providerAccountIds)
                data["providerAccountIds"].push(item);
        }
        data["isCleared"] = this.isCleared;
        data["publicToken"] = this.publicToken;
        return data; 
    }
}

export interface IEntityBankAccountsMappingAC {
    entityId: string;
    loanApplicationId: string;
    providerAccountIds?: number[] | undefined;
    isCleared: boolean;
    publicToken?: string | undefined;
}

export class UserInfoAddressAC implements IUserInfoAddressAC {
    user?: UserAC | undefined;
    address?: AddressAC | undefined;

    constructor(data?: IUserInfoAddressAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? UserAC.fromJS(_data["user"]) : <any>undefined;
            this.address = _data["address"] ? AddressAC.fromJS(_data["address"]) : <any>undefined;
        }
    }

    static fromJS(data: any): UserInfoAddressAC {
        data = typeof data === 'object' ? data : {};
        let result = new UserInfoAddressAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["address"] = this.address ? this.address.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IUserInfoAddressAC {
    user?: UserAC | undefined;
    address?: AddressAC | undefined;
}

export class PagedLoanApplicationAC implements IPagedLoanApplicationAC {
    loanApplications?: LoanApplicationAC[] | undefined;
    loanCount!: number;
    companyNames?: string[] | undefined;
    loanPurposes?: string[] | undefined;
    loanStatus?: string[] | undefined;

    constructor(data?: IPagedLoanApplicationAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["loanApplications"])) {
                this.loanApplications = [] as any;
                for (let item of _data["loanApplications"])
                    this.loanApplications!.push(LoanApplicationAC.fromJS(item));
            }
            this.loanCount = _data["loanCount"];
            if (Array.isArray(_data["companyNames"])) {
                this.companyNames = [] as any;
                for (let item of _data["companyNames"])
                    this.companyNames!.push(item);
            }
            if (Array.isArray(_data["loanPurposes"])) {
                this.loanPurposes = [] as any;
                for (let item of _data["loanPurposes"])
                    this.loanPurposes!.push(item);
            }
            if (Array.isArray(_data["loanStatus"])) {
                this.loanStatus = [] as any;
                for (let item of _data["loanStatus"])
                    this.loanStatus!.push(item);
            }
        }
    }

    static fromJS(data: any): PagedLoanApplicationAC {
        data = typeof data === 'object' ? data : {};
        let result = new PagedLoanApplicationAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.loanApplications)) {
            data["loanApplications"] = [];
            for (let item of this.loanApplications)
                data["loanApplications"].push(item.toJSON());
        }
        data["loanCount"] = this.loanCount;
        if (Array.isArray(this.companyNames)) {
            data["companyNames"] = [];
            for (let item of this.companyNames)
                data["companyNames"].push(item);
        }
        if (Array.isArray(this.loanPurposes)) {
            data["loanPurposes"] = [];
            for (let item of this.loanPurposes)
                data["loanPurposes"].push(item);
        }
        if (Array.isArray(this.loanStatus)) {
            data["loanStatus"] = [];
            for (let item of this.loanStatus)
                data["loanStatus"].push(item);
        }
        return data; 
    }
}

export interface IPagedLoanApplicationAC {
    loanApplications?: LoanApplicationAC[] | undefined;
    loanCount: number;
    companyNames?: string[] | undefined;
    loanPurposes?: string[] | undefined;
    loanStatus?: string[] | undefined;
}

export class EntityCreditReportJsonAC implements IEntityCreditReportJsonAC {
    entityId!: string;
    creditReportJson?: any | undefined;
    responseSource?: string | undefined;

    constructor(data?: IEntityCreditReportJsonAC) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.entityId = _data["entityId"];
            this.creditReportJson = _data["creditReportJson"];
            this.responseSource = _data["responseSource"];
        }
    }

    static fromJS(data: any): EntityCreditReportJsonAC {
        data = typeof data === 'object' ? data : {};
        let result = new EntityCreditReportJsonAC();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["entityId"] = this.entityId;
        data["creditReportJson"] = this.creditReportJson;
        data["responseSource"] = this.responseSource;
        return data; 
    }
}

export interface IEntityCreditReportJsonAC {
    entityId: string;
    creditReportJson?: any | undefined;
    responseSource?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}